{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"AAAA;;;;;EAKE;AACF,SAAS,aAAa,CAAC,EAAE,EAAE,KAAK,EAAE,EAAE,EAAE,QAAS,EAAE,SAAc,MAAM,EAAE,WAAW,GAAG,EAAE,EAAE,KAAK,GAAG,CAAC;IAChG,MAAM,aAAa,GAAG,QAAQ,CAAC,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,EAAE,WAAW,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;IAEnF,IAAI,OAAO,aAAa,KAAK,UAAU,IAAI,OAAO,aAAa,KAAK,QAAQ,IAAI,aAAa,KAAK,SAAS,EAAE;KAC5G;SAAM,IAAI,KAAK,CAAC,OAAO,CAAC,aAAa,CAAC,EAAE;QACvC,EAAE,CAAC,SAAS,EAAE,WAAW,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,YAAY,EAAE,KAAK,EAAE,CAAC,CAAA;QAC1E,MAAM,MAAM,GAAG,aAAa,CAAC,MAAM,CAAA;QACnC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,CAAC,EAAE,EAAE;YAC/B,KAAK,GAAG,aAAa,CAAC,EAAE,EAAE,aAAa,CAAC,CAAC,CAAC,EAAE,EAAE,EAAE,QAAQ,EAAE,aAAa,EAAE,WAAW,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC;SACxG;KACF;SAAM,IAAI,aAAa,KAAK,IAAI,IAAI,OAAO,aAAa,KAAK,QAAQ,EAAE;QACtE,EAAE,CAAC,SAAS,EAAE,WAAW,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,YAAY,EAAE,KAAK,EAAE,CAAC,CAAA;QAC1E,KAAK,IAAI,GAAG,IAAI,aAAa,EAAE;YAC7B,KAAK,GAAG,aAAa,CAAC,EAAE,EAAE,aAAa,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,QAAQ,EAAE,aAAa,EAAE,WAAW,CAAC,MAAM,CAAC,GAAG,CAAC,EAAE,KAAK,CAAC,CAAC;SAC5G;KACF;SAAM;QACL,EAAE,CAAC,SAAS,EAAE,WAAW,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,qBAAqB,IAAI,CAAC,SAAS,CAAC,aAAa,CAAC,GAAG,EAAE,KAAK,EAAE,CAAC,CAAA;KACpH;IAED,OAAO,KAAK,CAAA;AACd,CAAC;AACD,IAAI,GAAG,GAAG,CAAC,CAAA;AACX,MAAM,UAAU,SAAS,CAAC,KAAK,EAAE,EAAE,EAAE,QAAS;IAC5C,MAAM,EAAE,GAAG,GAAG,EAAE,CAAA;IAChB,MAAM,KAAK,GAAG,aAAa,CAAC,EAAE,EAAE,KAAK,EAAE,EAAE,EAAE,QAAQ,CAAC,CAAA;IACpD,EAAE,CAAC,SAAS,EAAE,YAAY,EAAE,KAAK,CAAC,CAAA;IAClC,OAAO,EAAE,CAAA;AACX,CAAC;AAoBD,MAAM,MAAM;IAEV,YAAY,OAAgB;QAC1B,IAAI,OAAO,CAAC,IAAI,KAAK,CAAC,EAAE;YACtB,IAAI,CAAC,KAAK,GAAG,EAAE,CAAA;SAChB;aAAM,IAAI,OAAO,CAAC,IAAI,KAAK,CAAC,EAAE;YAC7B,IAAI,CAAC,KAAK,GAAG,EAAE,CAAA;SAChB;aAAM,IAAI,OAAO,CAAC,IAAI,KAAK,CAAC,EAAE;YAC7B,IAAI,CAAC,KAAK,GAAG,OAAO,CAAC,KAAK,CAAA;SAC3B;IACH,CAAC;IACD,QAAQ,CAAC,OAAgB;QACvB,IAAI,OAAO,CAAC,IAAI,KAAK,CAAC,EAAE;YACtB,MAAM,IAAI,GAAG,OAAO,CAAC,IAAI,CAAA;YACzB,MAAM,WAAW,GAAG,IAAI,CAAC,MAAM,GAAG,CAAC,CAAA;YACnC,IAAI,MAAM,GAAG,IAAI,CAAC,KAAK,CAAA;YACvB,IAAI,CAAC,GAAG,CAAC,CAAA;YACT,KAAK,CAAC,EAAE,CAAC,GAAG,WAAW,EAAE,CAAC,EAAE,EAAE;gBAC1B,MAAM,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAA;aAC3B;YACD,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG,EAAE,CAAA;SACrB;aAAM,IAAI,OAAO,CAAC,IAAI,KAAK,CAAC,EAAE;YAC7B,MAAM,IAAI,GAAG,OAAO,CAAC,IAAI,CAAA;YACzB,MAAM,WAAW,GAAG,IAAI,CAAC,MAAM,GAAG,CAAC,CAAA;YACnC,IAAI,MAAM,GAAG,IAAI,CAAC,KAAK,CAAA;YACvB,IAAI,CAAC,GAAG,CAAC,CAAA;YACT,KAAK,CAAC,EAAE,CAAC,GAAG,WAAW,EAAE,CAAC,EAAE,EAAE;gBAC5B,MAAM,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAA;aACzB;YACD,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG,EAAE,CAAA;SACrB;aAAM,IAAI,OAAO,CAAC,IAAI,KAAK,CAAC,EAAE;YAC7B,MAAM,IAAI,GAAG,OAAO,CAAC,IAAI,CAAA;YACzB,MAAM,WAAW,GAAG,IAAI,CAAC,MAAM,GAAG,CAAC,CAAA;YACnC,IAAI,MAAM,GAAG,IAAI,CAAC,KAAK,CAAA;YACvB,IAAI,CAAC,GAAG,CAAC,CAAA;YACT,KAAK,CAAC,EAAE,CAAC,GAAG,WAAW,EAAE,CAAC,EAAE,EAAE;gBAC5B,MAAM,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAA;aACzB;YACD,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG,OAAO,CAAC,KAAK,CAAA;SAChC;IACH,CAAC;CACF;AAED,MAAM,OAAO,GAA6B,EAAE,CAAA;AAE5C,MAAM,UAAU,KAAK,CAAC,OAAgB;IACpC,IAAI,MAAM,GAAG,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC,CAAA;IAEhC,IAAI,CAAC,MAAM,EAAE;QACX,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC,GAAG,IAAI,MAAM,CAAC,OAAO,CAAC,CAAA;QACzC,OAAM;KACP;IAED,IAAI,OAAO,CAAC,IAAI,KAAK,CAAC,EAAE;QACtB,OAAO,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC,CAAA;QAC1B,OAAO,MAAM,CAAC,KAAK,CAAA;KACpB;IAED,MAAM,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAA;AAC1B,CAAC","sourcesContent":["/*\n  Type 0 = array\n  Type 1 = object\n  Type 2 = value\n  Type 3 = done\n*/\nfunction traversePaths(id, value, cb, replacer?, parent: any = window, currentPath = [], index = 0) {\n  const replacedValue = replacer ? replacer.call(parent, currentPath, value) : value;\n\n  if (typeof replacedValue === \"function\" || typeof replacedValue === \"symbol\" || replacedValue === undefined) {\n  } else if (Array.isArray(replacedValue)) {\n    cb(`{\"id\":${id},\"path\":${JSON.stringify(currentPath)},\"type\":0}`, index++)\n    const length = replacedValue.length\n    for (let x = 0; x < length; x++) {\n      index = traversePaths(id, replacedValue[x], cb, replacer, replacedValue, currentPath.concat(x), index);\n    }\n  } else if (replacedValue !== null && typeof replacedValue === \"object\") {\n    cb(`{\"id\":${id},\"path\":${JSON.stringify(currentPath)},\"type\":1}`, index++)\n    for (let key in replacedValue) {\n      index = traversePaths(id, replacedValue[key], cb, replacer, replacedValue, currentPath.concat(key), index);\n    }\n  } else {\n    cb(`{\"id\":${id},\"path\":${JSON.stringify(currentPath)},\"type\":2,\"value\":${JSON.stringify(replacedValue)}}`, index++)\n  }\n\n  return index\n}\nlet seq = 0\nexport function stringify(value, cb, replacer?) {\n  const id = seq++\n  const index = traversePaths(id, value, cb, replacer)\n  cb(`{\"id\":${id},\"type\":3}`, index)\n  return id\n}\n\nexport type Payload = {\n  id: number\n  type: 0\n  path: (string | number)[]\n} | {\n  id: number\n  type: 1\n  path: (string | number)[]\n} | {\n  id: number\n  type: 2\n  path: (string | number)[]\n  value: any\n} | {\n  id: number\n  type: 3\n}\n\nclass Parser {\n  value: any\n  constructor(payload: Payload) {\n    if (payload.type === 0) {\n      this.value = []\n    } else if (payload.type === 1) {\n      this.value = {}\n    } else if (payload.type === 2) {\n      this.value = payload.value\n    }\n  }\n  evaluate(payload: Payload) {\n    if (payload.type === 0) {\n      const path = payload.path\n      const nestedCount = path.length - 1\n      let target = this.value\n      let x = 0\n      for (x; x < nestedCount; x++) {\n          target = target[path[x]]\n      }\n      target[path[x]] = []\n    } else if (payload.type === 1) {\n      const path = payload.path\n      const nestedCount = path.length - 1\n      let target = this.value\n      let x = 0\n      for (x; x < nestedCount; x++) {\n        target = target[path[x]]\n      }\n      target[path[x]] = {}\n    } else if (payload.type === 2) {\n      const path = payload.path\n      const nestedCount = path.length - 1\n      let target = this.value\n      let x = 0\n      for (x; x < nestedCount; x++) {\n        target = target[path[x]]\n      }\n      target[path[x]] = payload.value\n    }\n  }\n}\n\nconst parsers: { [id: string]: Parser } = {}\n\nexport function parse(payload: Payload) {\n  let parser = parsers[payload.id]\n\n  if (!parser) {\n    parsers[payload.id] = new Parser(payload)\n    return\n  } \n  \n  if (payload.type === 3) {\n    delete parsers[payload.id]\n    return parser.value\n  }\n\n  parser.evaluate(payload)\n}"]}