"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
  Type 0 = array
  Type 1 = object
  Type 2 = value
  Type 3 = done
*/
function traversePaths(id, value, cb, replacer, parent = window, currentPath = [], index = 0) {
    const replacedValue = replacer ? replacer.call(parent, currentPath, value) : value;
    if (typeof replacedValue === "function" || typeof replacedValue === "symbol" || replacedValue === undefined) {
    }
    else if (Array.isArray(replacedValue)) {
        cb(`{"id":${id},"path":${JSON.stringify(currentPath)},"type":0}`, index++);
        const length = replacedValue.length;
        for (let x = 0; x < length; x++) {
            index = traversePaths(id, replacedValue[x], cb, replacer, replacedValue, currentPath.concat(x), index);
        }
    }
    else if (replacedValue !== null && typeof replacedValue === "object") {
        cb(`{"id":${id},"path":${JSON.stringify(currentPath)},"type":1}`, index++);
        for (let key in replacedValue) {
            index = traversePaths(id, replacedValue[key], cb, replacer, replacedValue, currentPath.concat(key), index);
        }
    }
    else {
        cb(`{"id":${id},"path":${JSON.stringify(currentPath)},"type":2,"value":${JSON.stringify(replacedValue)}}`, index++);
    }
    return index;
}
let seq = 0;
function stringify(value, cb, replacer) {
    const id = seq++;
    const index = traversePaths(id, value, cb, replacer);
    cb(`{"id":${id},"type":3}`, index);
    return id;
}
exports.stringify = stringify;
class Parser {
    constructor(payload) {
        if (payload.type === 0) {
            this.value = [];
        }
        else if (payload.type === 1) {
            this.value = {};
        }
        else if (payload.type === 2) {
            this.value = payload.value;
        }
    }
    evaluate(payload) {
        if (payload.type === 0) {
            const path = payload.path;
            const nestedCount = path.length - 1;
            let target = this.value;
            let x = 0;
            for (x; x < nestedCount; x++) {
                target = target[path[x]];
            }
            target[path[x]] = [];
        }
        else if (payload.type === 1) {
            const path = payload.path;
            const nestedCount = path.length - 1;
            let target = this.value;
            let x = 0;
            for (x; x < nestedCount; x++) {
                target = target[path[x]];
            }
            target[path[x]] = {};
        }
        else if (payload.type === 2) {
            const path = payload.path;
            const nestedCount = path.length - 1;
            let target = this.value;
            let x = 0;
            for (x; x < nestedCount; x++) {
                target = target[path[x]];
            }
            target[path[x]] = payload.value;
        }
    }
}
const parsers = {};
function parse(payload) {
    let parser = parsers[payload.id];
    if (!parser) {
        parsers[payload.id] = new Parser(payload);
        return;
    }
    if (payload.type === 3) {
        delete parsers[payload.id];
        return parser.value;
    }
    parser.evaluate(payload);
}
exports.parse = parse;
//# sourceMappingURL=index.js.map