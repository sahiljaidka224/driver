{"version":3,"file":"namespaced.js","sourceRoot":"","sources":["../../src/config/namespaced.ts"],"names":[],"mappings":"AAaA,SAAS,qBAAqB,CAC5B,MAAqE,EACrE,IAAY,EACZ,MAAsB;IAEtB,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,YAAY,EAAE,KAAK,EAAE,GAAmB,MAAM,CAAA;IAExE,IAAI,OAAO,EAAE;QACX,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,OAAO,CAAA;KAC/B;IACD,IAAI,OAAO,EAAE;QACX,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,OAAO,CAAA;KAC/B;IACD,IAAI,KAAK,EAAE;QACT,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,KAAK,CAAA;KAC3B;IACD,IAAI,YAAY,EAAE;QAChB,MAAM,CAAC,YAAY,CAAC,IAAI,CAAC,GAAG,YAAY,CAAA;KACzC;AACH,CAAC;AAED,MAAM,UAAU,UAAU,CACxB,UAAa;IAOb,MAAM,MAAM,GAAQ;QAClB,YAAY,EAAE,EAAE;QAChB,OAAO,EAAE,EAAE;QACX,OAAO,EAAE,EAAE;QACX,KAAK,EAAE,EAAE;KACV,CAAA;IAED,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;QACvC,qBAAqB,CAAC,MAAM,EAAE,IAAI,EAAE,UAAU,CAAC,IAAI,CAAC,CAAC,CAAA;IACvD,CAAC,CAAC,CAAA;IAEF,OAAO,MAAM,CAAC,MAAM,CAAC;QACnB,OAAO,EAAE,MAAM,CAAC,OAAO;QACvB,OAAO,EAAE,MAAM,CAAC,OAAO;QACvB,KAAK,EAAE,MAAM,CAAC,KAAK;QACnB,YAAY,EAAE,CAAC,OAAO,EAAE,GAAG,EAAE,EAAE,CAC7B,OAAO,CAAC,GAAG,CACT,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,EAAE,CAC3C,MAAM,CAAC,YAAY,CAAC,GAAG,CAAC,iCAEjB,OAAO,KACV,SAAS,kCACJ,OAAO,CAAC,SAAS,KACpB,aAAa,EAAE,OAAO,CAAC,SAAS,CAAC,aAAa,CAAC,MAAM,CAAC,GAAG,CAAC,QAG9D,GAAG,CACJ,CACF,CACF;KACJ,CAAC,CAAA;AACJ,CAAC","sourcesContent":["import { IConfiguration } from '../'\nimport { SubType } from '../internalTypes'\n\ninterface NamespacedConfiguration {\n  [namespace: string]: {\n    onInitialize?: any\n    state?: {}\n    effects?: {}\n    actions?: {}\n    reactions?: {}\n  }\n}\n\nfunction parseNamespacedConfig(\n  result: { actions: any; effects: any; state: any; initializers: any },\n  name: string,\n  config: IConfiguration\n) {\n  const { actions, effects, onInitialize, state }: IConfiguration = config\n\n  if (actions) {\n    result.actions[name] = actions\n  }\n  if (effects) {\n    result.effects[name] = effects\n  }\n  if (state) {\n    result.state[name] = state\n  }\n  if (onInitialize) {\n    result.initializers[name] = onInitialize\n  }\n}\n\nexport function namespaced<T extends NamespacedConfiguration>(\n  namespaces: T\n): {\n  onInitialize?: any\n  state: SubType<{ [P in keyof T]: T[P]['state'] }, object>\n  effects: SubType<{ [P in keyof T]: T[P]['effects'] }, object>\n  actions: SubType<{ [P in keyof T]: T[P]['actions'] }, object>\n} {\n  const result: any = {\n    initializers: {},\n    actions: {},\n    effects: {},\n    state: {},\n  }\n\n  Object.keys(namespaces).forEach((name) => {\n    parseNamespacedConfig(result, name, namespaces[name])\n  })\n\n  return Object.assign({\n    actions: result.actions,\n    effects: result.effects,\n    state: result.state,\n    onInitialize: (context, app) =>\n      Promise.all(\n        Object.keys(result.initializers).map((key) =>\n          result.initializers[key](\n            {\n              ...context,\n              execution: {\n                ...context.execution,\n                namespacePath: context.execution.namespacePath.concat(key),\n              },\n            },\n            app\n          )\n        )\n      ),\n  })\n}\n"]}