import isPlainObject from 'is-plain-obj';
function copy(target, source) {
    return Object.keys(source).reduce((aggr, key) => {
        if (key === '__esModule') {
            return aggr;
        }
        if (isPlainObject(source[key])) {
            aggr[key] = copy(target[key] || {}, source[key]);
        }
        else if (Array.isArray(source[key])) {
            aggr[key] = source[key];
        }
        else {
            const originalDescriptor = Object.getOwnPropertyDescriptor(source, key);
            const isAGetter = originalDescriptor && 'get' in originalDescriptor;
            const value = source[key];
            if (isAGetter) {
                Object.defineProperty(aggr, key, originalDescriptor);
            }
            else {
                aggr[key] = value;
            }
        }
        return aggr;
    }, target);
}
export function merge(...configurations) {
    const initializers = configurations.reduce((aggr, config) => config.onInitialize ? aggr.concat(config.onInitialize) : aggr, []);
    const rootConfiguration = configurations.shift();
    const reducedConfigurations = configurations.reduce((aggr, config) => {
        const stateDuplicates = aggr.state
            ? Object.keys(aggr.state).some((key) => config.state ? Object.keys(config.state).includes(key) : false)
            : false;
        const actionsDuplicates = aggr.actions
            ? Object.keys(aggr.actions).some((key) => config.actions ? Object.keys(config.actions).includes(key) : false)
            : false;
        const effectsDuplicates = aggr.effects
            ? Object.keys(aggr.effects).some((key) => config.effects ? Object.keys(config.effects).includes(key) : false)
            : false;
        if (stateDuplicates) {
            throw new Error('Merge conflict: at least one state definition contains a duplicate key');
        }
        if (actionsDuplicates) {
            throw new Error('Merge conflict: at least one actions definition contains a duplicate key');
        }
        if (effectsDuplicates) {
            throw new Error('Merge conflict: at least one effects definition contains a duplicate key');
        }
        return {
            onInitialize: aggr.onInitialize,
            state: copy(aggr.state, config.state || {}),
            effects: Object.assign(Object.assign({}, aggr.effects), config.effects),
            actions: Object.assign(Object.assign({}, aggr.actions), config.actions),
        };
    }, Object.assign(Object.assign({}, rootConfiguration), { onInitialize: initializers.length
            ? (context, value) => Promise.all(initializers.map((cb) => cb(context, value)))
            : undefined }));
    return reducedConfigurations;
}
//# sourceMappingURL=merge.js.map