import { EventEmitter } from 'betsy';
import isPlainObject from 'is-plain-obj';
import { IS_PROXY, PATH, ProxyStateTree, VALUE, } from 'proxy-state-tree';
import { Derived, IS_DERIVED, IS_DERIVED_CONSTRUCTOR } from './derived';
import { Devtools } from './Devtools';
import { EventType } from './internalTypes';
import { createContext, createMutationOperator, createNextPath, createOperator, operatorStarted, operatorStopped, } from './operator';
import { proxifyEffects } from './proxyfyEffects';
import { rehydrate } from './rehydrate';
import { EXECUTION, IS_OPERATOR, IS_TEST, MODE_DEFAULT, MODE_SSR, MODE_TEST, MockedEventEmitter, createActionsProxy, deepCopy, getActionPaths, getChangeMutations, getFunctionName, isPromise, processState } from './utils';
export * from './types';
export { createOperator, createMutationOperator };
export { MODE_DEFAULT, MODE_TEST, MODE_SSR } from './utils';
export { SERIALIZE, rehydrate } from './rehydrate';
export { statemachine } from './statemachine';
export const derived = (cb) => {
    cb[IS_DERIVED_CONSTRUCTOR] = true;
    return cb;
};
export { json } from './utils';
export function createOvermindSSR(config) {
    const ssr = new Overmind(config, {
        devtools: false,
    }, {
        mode: MODE_SSR,
    });
    const mutationTree = ssr.proxyStateTree.getMutationTree();
    ssr.state = mutationTree.state;
    ssr.hydrate = () => {
        return mutationTree.flush().mutations;
    };
    return ssr;
}
export function createOvermindMock(config, mockedEffects) {
    const mock = new Overmind(Object.assign({}, config, {
        state: deepCopy(config.state),
    }), {
        devtools: false,
    }, {
        mode: MODE_TEST,
        options: {
            effectsCallback: (effect) => {
                const mockedEffect = (effect.name
                    ? effect.name.split('.')
                    : []).reduce((aggr, key) => (aggr ? aggr[key] : aggr), mockedEffects);
                if (!mockedEffect || (mockedEffect && !mockedEffect[effect.method])) {
                    throw new Error(`The effect "${effect.name}" with method ${effect.method} has not been mocked`);
                }
                return mockedEffect[effect.method](...effect.args);
            },
        },
    });
    const action = mock.createAction('onInitialize', config.onInitialize);
    mock.onInitialize = () => action(mock);
    mock.mutations = [];
    return mock;
}
export function createOvermind(config, options) {
    return new Overmind(config, options, { mode: MODE_DEFAULT });
}
const hotReloadingCache = {};
// We do not use IConfig<Config> directly to type the class in order to avoid
// the 'import(...)' function to be used in exported types.
export class Overmind {
    constructor(configuration, options = {}, mode = {
        mode: MODE_DEFAULT,
    }) {
        this.actionReferences = {};
        this.nextExecutionId = 0;
        this.reydrateMutationsForHotReloading = [];
        this.reaction = (stateCallback, updateCallback, options = {}) => {
            let disposer;
            if (options.nested) {
                const value = stateCallback(this.state);
                if (!value || !value[IS_PROXY]) {
                    throw new Error('You have to return an object or array from the Overmind state when using a "nested" reaction');
                }
                const path = value[PATH];
                disposer = this.addFlushListener((mutations) => {
                    mutations.forEach((mutation) => {
                        if (mutation.path.startsWith(path)) {
                            updateCallback(path.split(this.delimiter).reduce((aggr, key) => aggr[key], this.state));
                        }
                    });
                });
            }
            else {
                const tree = this.proxyStateTree.getTrackStateTree();
                let returnValue;
                const updateReaction = () => {
                    tree.trackScope(() => (returnValue = stateCallback(tree.state)), () => {
                        updateReaction();
                        updateCallback(returnValue);
                    });
                };
                updateReaction();
                disposer = () => {
                    tree.dispose();
                };
            }
            if (options.immediate) {
                updateCallback(stateCallback(this.state));
            }
            return disposer;
        };
        this.addMutationListener = (cb) => {
            return this.proxyStateTree.onMutation(cb);
        };
        this.addFlushListener = (cb) => {
            return this.proxyStateTree.onFlush(cb);
        };
        const name = options.name || 'OvermindApp';
        this.delimiter = options.delimiter || '.';
        if ((!process.env.NODE_ENV || process.env.NODE_ENV === 'development') &&
            mode.mode === MODE_DEFAULT &&
            options.hotReloading !== false &&
            !(process && process.title && process.title.includes('node'))) {
            if (hotReloadingCache[name]) {
                return hotReloadingCache[name].reconfigure(configuration);
            }
            else {
                hotReloadingCache[name] = this;
            }
        }
        /*
          Set up an eventHub to trigger information from derived, computed and reactions
        */
        const eventHub = mode.mode === MODE_SSR
            ? new MockedEventEmitter()
            : new EventEmitter();
        /*
          Create the proxy state tree instance with the state and a wrapper to expose
          the eventHub
        */
        const proxyStateTree = this.createProxyStateTree(configuration, eventHub, mode.mode === MODE_SSR ? false : process.env.NODE_ENV === 'development');
        this.originalConfiguration = configuration;
        this.state = proxyStateTree.state;
        this.effects = configuration.effects || {};
        this.proxyStateTree = proxyStateTree;
        this.eventHub = eventHub;
        this.mode = mode;
        /*
          Expose the created actions
        */
        this.actions = this.getActions(configuration.actions);
        if (mode.mode === MODE_SSR) {
            return;
        }
        if (process.env.NODE_ENV === 'development' &&
            mode.mode === MODE_DEFAULT &&
            typeof window !== 'undefined') {
            let warning = 'OVERMIND: You are running in DEVELOPMENT mode.';
            if (options.logProxies !== true) {
                const originalConsoleLog = console.log;
                console.log = (...args) => originalConsoleLog.apply(console, args.map((arg) => (arg && arg[IS_PROXY] ? arg[VALUE] : arg)));
                warning +=
                    '\n\n - To improve debugging experience "console.log" will NOT log proxies from Overmind, but the actual value. Please see docs to turn off this behaviour';
            }
            if (options.devtools ||
                (typeof location !== 'undefined' &&
                    location.hostname === 'localhost' &&
                    options.devtools !== false)) {
                const host = options.devtools === true ? 'localhost:3031' : options.devtools;
                const name = options.name
                    ? options.name
                    : typeof document === 'undefined'
                        ? 'NoName'
                        : document.title || 'NoName';
                this.initializeDevtools(host, name, eventHub, proxyStateTree.sourceState, configuration.actions);
            }
            else if (options.devtools !== false) {
                warning +=
                    '\n\n - You are not running on localhost. You will have to manually define the devtools option to connect';
            }
            if (!IS_TEST) {
                console.warn(warning);
            }
        }
        if (process.env.NODE_ENV === 'production' && mode.mode === MODE_DEFAULT) {
            eventHub.on(EventType.OPERATOR_ASYNC, (execution) => {
                if (!execution.parentExecution ||
                    !execution.parentExecution.isRunning) {
                    proxyStateTree.getMutationTree().flush(true);
                }
            });
            eventHub.on(EventType.ACTION_END, (execution) => {
                if (!execution.parentExecution || !execution.parentExecution.isRunning)
                    proxyStateTree.getMutationTree().flush();
            });
            let nextTick;
            const flushTree = () => {
                proxyStateTree.getMutationTree().flush(true);
            };
            this.proxyStateTree.onMutation(() => {
                nextTick && clearTimeout(nextTick);
                nextTick = setTimeout(flushTree, 0);
            });
        }
        else if (mode.mode === MODE_DEFAULT || mode.mode === MODE_TEST) {
            if (process.env.NODE_ENV === 'test' || (this.devtools && options.hotReloading !== false)) {
                eventHub.on(EventType.MUTATIONS, (execution) => {
                    this.reydrateMutationsForHotReloading = this.reydrateMutationsForHotReloading.concat(execution.mutations);
                });
            }
            eventHub.on(EventType.OPERATOR_ASYNC, (execution) => {
                if (!execution.parentExecution ||
                    !execution.parentExecution.isRunning) {
                    const flushData = execution.flush(true);
                    if (this.devtools && flushData.mutations.length) {
                        this.devtools.send({
                            type: 'flush',
                            data: Object.assign(Object.assign({}, execution), flushData),
                        });
                    }
                }
            });
            eventHub.on(EventType.ACTION_END, (execution) => {
                if (!execution.parentExecution ||
                    !execution.parentExecution.isRunning) {
                    const flushData = execution.flush();
                    if (this.devtools && flushData.mutations.length) {
                        this.devtools.send({
                            type: 'flush',
                            data: Object.assign(Object.assign({}, execution), flushData),
                        });
                    }
                }
            });
        }
        if (mode.mode === MODE_DEFAULT && configuration.onInitialize) {
            const onInitialize = this.createAction('onInitialize', configuration.onInitialize);
            this.initialized = Promise.resolve(onInitialize(this));
        }
        else {
            this.initialized = Promise.resolve(null);
        }
    }
    createProxyStateTree(configuration, eventHub, devmode) {
        const proxyStateTree = new ProxyStateTree(this.getState(configuration), {
            devmode,
            delimiter: this.delimiter,
            onFunction: (tree, path, func) => {
                if (func[IS_DERIVED]) {
                    return { func, value: func(eventHub, tree, proxyStateTree, path.split(this.delimiter)) };
                }
                if (func[IS_DERIVED_CONSTRUCTOR]) {
                    const derived = new Derived(func);
                    return {
                        func: derived,
                        value: derived(eventHub, tree, proxyStateTree, path.split(this.delimiter))
                    };
                }
                return {
                    func,
                    value: func
                };
            },
            onGetter: devmode
                ? (path, value) => {
                    this.eventHub.emitAsync(EventType.GETTER, {
                        path,
                        value
                    });
                }
                : undefined,
        });
        return proxyStateTree;
    }
    createExecution(name, action, parentExecution) {
        const namespacePath = name.split('.');
        namespacePath.pop();
        if (process.env.NODE_ENV === 'production') {
            return {
                [EXECUTION]: true,
                parentExecution,
                namespacePath,
                actionName: name,
                getMutationTree: () => {
                    return this.proxyStateTree.getMutationTree();
                },
                getTrackStateTree: () => {
                    return this.proxyStateTree.getTrackStateTree();
                },
                emit: this.eventHub.emit.bind(this.eventHub),
            };
        }
        const mutationTrees = [];
        const execution = {
            [EXECUTION]: true,
            namespacePath,
            actionId: name,
            executionId: this.nextExecutionId++,
            actionName: name,
            operatorId: 0,
            isRunning: true,
            parentExecution,
            path: [],
            emit: this.eventHub.emit.bind(this.eventHub),
            send: this.devtools ? this.devtools.send.bind(this.devtools) : () => { },
            trackEffects: this.trackEffects.bind(this, this.effects),
            getNextOperatorId: (() => {
                let currentOperatorId = 0;
                return () => ++currentOperatorId;
            })(),
            flush: parentExecution
                ? parentExecution.flush
                : (isAsync) => {
                    return this.proxyStateTree.flush(mutationTrees, isAsync);
                },
            getMutationTree: parentExecution
                ? parentExecution.getMutationTree
                : () => {
                    const mutationTree = this.proxyStateTree.getMutationTree();
                    mutationTrees.push(mutationTree);
                    if (this.mode.mode === MODE_TEST) {
                        mutationTree.onMutation((mutation) => {
                            this.addExecutionMutation(mutation);
                        });
                    }
                    return mutationTree;
                },
            getTrackStateTree: () => {
                return this.proxyStateTree.getTrackStateTree();
            },
            onFlush: (cb) => {
                return this.proxyStateTree.onFlush(cb);
            },
            scopeValue: (value, tree) => {
                return this.scopeValue(value, tree);
            },
        };
        return execution;
    }
    createContext(execution, tree) {
        return {
            state: tree.state,
            actions: createActionsProxy(this.actions, (action) => {
                return (value) => action(value, execution.isRunning ? execution : null);
            }),
            execution,
            proxyStateTree: this.proxyStateTree,
            effects: this.trackEffects(this.effects, execution),
        };
    }
    scopeValue(value, tree) {
        if (!value) {
            return value;
        }
        if (value[IS_PROXY]) {
            return this.proxyStateTree.rescope(value, tree);
        }
        else if (isPlainObject(value)) {
            return Object.assign({}, ...Object.keys(value).map((key) => ({
                [key]: this.proxyStateTree.rescope(value[key], tree),
            })));
        }
        else {
            return value;
        }
    }
    addExecutionMutation(mutation) {
        ;
        this.mutations.push(mutation);
    }
    createAction(name, originalAction) {
        this.actionReferences[name] = originalAction;
        const actionFunc = (value, boundExecution) => {
            const action = this.actionReferences[name];
            // Developer might unintentionally pass more arguments, so have to ensure
            // that it is an actual execution
            boundExecution =
                boundExecution && boundExecution[EXECUTION] ? boundExecution : undefined;
            if (process.env.NODE_ENV === 'production' || action[IS_OPERATOR]) {
                const execution = this.createExecution(name, action, boundExecution);
                this.eventHub.emit(EventType.ACTION_START, Object.assign(Object.assign({}, execution), { value }));
                if (action[IS_OPERATOR]) {
                    return new Promise((resolve, reject) => {
                        action(null, Object.assign(Object.assign({}, this.createContext(execution, this.proxyStateTree)), { value }), (err, finalContext) => {
                            execution.isRunning = false;
                            finalContext &&
                                this.eventHub.emit(EventType.ACTION_END, Object.assign(Object.assign({}, finalContext.execution), { operatorId: finalContext.execution.operatorId - 1 }));
                            if (err)
                                reject(err);
                            else {
                                resolve(this.mode.mode === MODE_TEST
                                    ? finalContext.execution
                                    : undefined);
                            }
                        });
                    });
                }
                else {
                    const returnValue = action(this.createContext(execution, execution.getMutationTree()), value);
                    this.eventHub.emit(EventType.ACTION_END, execution);
                    return returnValue;
                }
            }
            else {
                const execution = Object.assign(Object.assign({}, this.createExecution(name, action, boundExecution)), { operatorId: 0, type: 'action' });
                this.eventHub.emit(EventType.ACTION_START, Object.assign(Object.assign({}, execution), { value }));
                this.eventHub.emit(EventType.OPERATOR_START, execution);
                const mutationTree = execution.getMutationTree();
                mutationTree.onMutation((mutation) => {
                    this.eventHub.emit(EventType.MUTATIONS, Object.assign(Object.assign({}, execution), { mutations: [mutation] }));
                });
                const scopedValue = this.scopeValue(value, mutationTree);
                const context = this.createContext(execution, mutationTree);
                try {
                    let result = action(context, scopedValue);
                    if (isPromise(result)) {
                        this.eventHub.emit(EventType.OPERATOR_ASYNC, execution);
                        result = result
                            .then((promiseResult) => {
                            execution.isRunning = false;
                            if (!boundExecution) {
                                mutationTree.dispose();
                            }
                            this.eventHub.emit(EventType.OPERATOR_END, Object.assign(Object.assign({}, execution), { isAsync: true, result: undefined }));
                            this.eventHub.emit(EventType.ACTION_END, execution);
                            return promiseResult;
                        })
                            .catch((error) => {
                            execution.isRunning = false;
                            if (!boundExecution) {
                                mutationTree.dispose();
                            }
                            this.eventHub.emit(EventType.OPERATOR_END, Object.assign(Object.assign({}, execution), { isAsync: true, result: undefined, error: error.message }));
                            this.eventHub.emit(EventType.ACTION_END, execution);
                            throw error;
                        });
                    }
                    else {
                        execution.isRunning = false;
                        if (!boundExecution) {
                            mutationTree.dispose();
                        }
                        this.eventHub.emit(EventType.OPERATOR_END, Object.assign(Object.assign({}, execution), { isAsync: false, result: undefined }));
                        this.eventHub.emit(EventType.ACTION_END, execution);
                    }
                    let pendingFlush;
                    mutationTree.onMutation((mutation) => {
                        if (pendingFlush) {
                            clearTimeout(pendingFlush);
                        }
                        if (this.mode.mode === MODE_TEST) {
                            this.addExecutionMutation(mutation);
                        }
                        pendingFlush = setTimeout(() => {
                            pendingFlush = null;
                            const flushData = execution.flush(true);
                            if (this.devtools && flushData.mutations.length) {
                                this.devtools.send({
                                    type: 'flush',
                                    data: Object.assign(Object.assign(Object.assign({}, execution), flushData), { mutations: flushData.mutations }),
                                });
                            }
                        });
                    });
                    return result;
                }
                catch (err) {
                    this.eventHub.emit(EventType.OPERATOR_END, Object.assign(Object.assign({}, execution), { isAsync: false, result: undefined, error: err.message }));
                    this.eventHub.emit(EventType.ACTION_END, execution);
                    throw err;
                }
            }
        };
        return actionFunc;
    }
    trackEffects(effects = {}, execution) {
        if (process.env.NODE_ENV === 'production') {
            return effects;
        }
        return proxifyEffects(this.effects, (effect) => {
            let result;
            try {
                if (this.mode.mode === MODE_TEST) {
                    const mode = this.mode;
                    result = mode.options.effectsCallback(effect);
                }
                else {
                    this.eventHub.emit(EventType.EFFECT, Object.assign(Object.assign(Object.assign({}, execution), effect), { args: effect.args, isPending: true, error: false }));
                    result = effect.func.apply(this, effect.args);
                }
            }
            catch (error) {
                // eslint-disable-next-line standard/no-callback-literal
                this.eventHub.emit(EventType.EFFECT, Object.assign(Object.assign(Object.assign({}, execution), effect), { args: effect.args, isPending: false, error: error.message }));
                throw error;
            }
            if (isPromise(result)) {
                // eslint-disable-next-line standard/no-callback-literal
                this.eventHub.emit(EventType.EFFECT, Object.assign(Object.assign(Object.assign({}, execution), effect), { args: effect.args, isPending: true, error: false }));
                return result
                    .then((promisedResult) => {
                    // eslint-disable-next-line standard/no-callback-literal
                    this.eventHub.emit(EventType.EFFECT, Object.assign(Object.assign(Object.assign({}, execution), effect), { args: effect.args, result: promisedResult, isPending: false, error: false }));
                    return promisedResult;
                })
                    .catch((error) => {
                    this.eventHub.emit(EventType.EFFECT, Object.assign(Object.assign(Object.assign({}, execution), effect), { args: effect.args, isPending: false, error: error && error.message }));
                    throw error;
                });
            }
            // eslint-disable-next-line standard/no-callback-literal
            this.eventHub.emit(EventType.EFFECT, Object.assign(Object.assign(Object.assign({}, execution), effect), { args: effect.args, result: result, isPending: false, error: false }));
            return result;
        });
    }
    initializeDevtools(host, name, eventHub, initialState, actions) {
        if (process.env.NODE_ENV === 'production')
            return;
        const devtools = new Devtools(name);
        devtools.connect(host, (message) => {
            switch (message.type) {
                case 'refresh':
                    location.reload(true);
                    break;
                case 'executeAction':
                    const action = message.data.name
                        .split('.')
                        .reduce((aggr, key) => aggr[key], this.actions);
                    message.data.payload
                        ? action(JSON.parse(message.data.payload))
                        : action();
                    break;
                case 'mutation':
                    const tree = this.proxyStateTree.getMutationTree();
                    const path = message.data.path.slice();
                    const value = JSON.parse(`{ "value": ${message.data.value} }`).value;
                    const key = path.pop();
                    const state = path.reduce((aggr, key) => aggr[key], tree.state);
                    state[key] = value;
                    tree.flush(true);
                    tree.dispose();
                    this.devtools.send({
                        type: 'state',
                        data: {
                            path: message.data.path,
                            value,
                        },
                    });
            }
        });
        for (let type in EventType) {
            eventHub.on(EventType[type], ((eventType) => (data) => {
                devtools.send({
                    type: EventType[type],
                    data,
                });
                if (eventType === EventType.MUTATIONS) {
                    // We want to trigger property access when setting objects and arrays, as any derived set would
                    // then trigger and update the devtools
                    data.mutations.forEach((mutation) => {
                        const value = mutation.path.split(this.delimiter).reduce((aggr, key) => aggr[key], this.proxyStateTree.state);
                        if (isPlainObject(value)) {
                            Object.keys(value).forEach((key) => value[key]);
                        }
                        else if (Array.isArray(value)) {
                            value.forEach((item) => {
                                if (isPlainObject(item)) {
                                    Object.keys(item).forEach((key) => item[key]);
                                }
                            });
                        }
                    });
                }
                // Access the derived which will trigger calculation and devtools
                if (eventType === EventType.DERIVED_DIRTY) {
                    data.derivedPath
                        .reduce((aggr, key) => aggr[key], this.proxyStateTree.state);
                }
            })(EventType[type]));
        }
        devtools.send({
            type: 'init',
            data: {
                state: this.proxyStateTree.state,
                actions: getActionPaths(actions),
                delimiter: this.delimiter
            },
        });
        this.devtools = devtools;
    }
    getState(configuration) {
        let state = {};
        if (configuration.state) {
            state = processState(configuration.state);
        }
        return state;
    }
    getActions(actions = {}, path = []) {
        return Object.keys(actions).reduce((aggr, name) => {
            if (typeof actions[name] === 'function') {
                const action = this.createAction(path.concat(name).join('.'), actions[name]);
                action.displayName = path.concat(name).join('.');
                return Object.assign(aggr, {
                    [name]: action,
                });
            }
            return Object.assign(aggr, {
                [name]: this.getActions(actions[name], path.concat(name)),
            });
        }, {});
    }
    /*
      Related to hot reloading we update the existing action references and add any new
      actions.
    */
    updateActions(actions = {}, path = []) {
        Object.keys(actions).forEach((name) => {
            if (typeof actions[name] === 'function') {
                const actionName = path.concat(name).join('.');
                if (this.actionReferences[actionName]) {
                    this.actionReferences[actionName] = actions[name];
                }
                else {
                    const target = path.reduce((aggr, key) => {
                        if (!aggr[key]) {
                            aggr[key] = {};
                        }
                        return aggr[key];
                    }, this.actions);
                    target[name] = this.createAction(actionName, actions[name]);
                    target[name].displayName = path.concat(name).join('.');
                }
            }
            else {
                this.updateActions(actions[name], path.concat(name));
            }
        }, {});
    }
    getTrackStateTree() {
        return this.proxyStateTree.getTrackStateTree();
    }
    getMutationTree() {
        return this.proxyStateTree.getMutationTree();
    }
    reconfigure(configuration) {
        const changeMutations = getChangeMutations(this.originalConfiguration.state, configuration.state || {});
        this.updateActions(configuration.actions);
        this.effects = configuration.effects || {};
        const mutationTree = this.proxyStateTree.getMutationTree();
        // We change the state to match the new structure
        rehydrate(mutationTree.state, changeMutations);
        // We run any mutations ran during the session, it might fail though
        // as the state structure might have changed, but no worries we just
        // ignore that
        this.reydrateMutationsForHotReloading.forEach((mutation) => {
            try {
                rehydrate(mutationTree.state, [mutation]);
            }
            catch (error) {
                // No worries, structure changed and we do not want to mutate anyways
            }
        });
        mutationTree.flush();
        mutationTree.dispose();
        if (this.devtools) {
            this.devtools.send({
                type: 're_init',
                data: {
                    state: this.state,
                    actions: getActionPaths(configuration.actions),
                },
            });
        }
        return this;
    }
}
export function pipe(...operators) {
    const instance = (err, context, next, final = next) => {
        if (err)
            next(err, context);
        else {
            let operatorIndex = 0;
            const run = (operatorErr, operatorContext) => {
                const operator = operators[operatorIndex++];
                try {
                    ;
                    (operator || next)(operatorErr, operatorContext, run, final);
                }
                catch (operatorError) {
                    ;
                    (operator || next)(operatorError, operatorContext, run, final);
                }
            };
            run(null, context);
        }
    };
    instance[IS_OPERATOR] = true;
    return instance;
}
/*
  OPERATORS
*/
export function forEach(forEachItemOperator) {
    const instance = (err, context, next) => {
        if (err)
            next(err, context);
        else {
            let array = context.value;
            let evaluatingCount = array.length;
            let lastContext;
            let hasErrored = false;
            const evaluate = (err) => {
                if (hasErrored) {
                    return;
                }
                if (err) {
                    hasErrored = true;
                    return next(err);
                }
                evaluatingCount--;
                if (!evaluatingCount) {
                    operatorStopped(context, context.value);
                    next(null, createContext(lastContext, context.value, lastContext.execution.path &&
                        lastContext.execution.path.slice(0, lastContext.execution.path.length - 1)));
                }
            };
            operatorStarted('forEach', '', context);
            if (array.length) {
                array.forEach((value, index) => {
                    lastContext = createContext(lastContext || context, value, context.execution.path &&
                        context.execution.path.concat(String(index)));
                    const nextWithPath = createNextPath(evaluate);
                    // @ts-ignore
                    forEachItemOperator(null, lastContext, nextWithPath);
                });
            }
            else {
                operatorStopped(context, context.value);
                next(null, createContext(context, context.value));
            }
        }
    };
    instance[IS_OPERATOR] = true;
    return instance;
}
export function parallel(...operators) {
    const instance = (err, context, next) => {
        if (err)
            next(err, context);
        else {
            let evaluatingCount = operators.length;
            let lastContext;
            let hasErrored = false;
            const evaluate = (err) => {
                if (hasErrored) {
                    return;
                }
                if (err) {
                    hasErrored = true;
                    return next(err, lastContext);
                }
                evaluatingCount--;
                if (!evaluatingCount) {
                    operatorStopped(context, context.value);
                    next(null, createContext(lastContext, context.value, lastContext.execution.path &&
                        lastContext.execution.path.slice(0, lastContext.execution.path.length - 1)));
                }
            };
            operatorStarted('parallel', '', context);
            operators.forEach((operator, index) => {
                lastContext = createContext(lastContext || context, context.value, context.execution.path && context.execution.path.concat(String(index)));
                const nextWithPath = createNextPath(evaluate);
                // @ts-ignore
                operator(null, lastContext, nextWithPath);
            });
        }
    };
    instance[IS_OPERATOR] = true;
    return instance;
}
export function map(operation) {
    return createOperator('map', getFunctionName(operation), (err, context, value, next) => {
        if (err)
            next(err, value);
        else
            next(null, operation(context, value));
    });
}
export function noop() {
    return createOperator('noop', '', (err, context, value, next) => {
        if (err)
            next(err, value);
        else
            next(null, value);
    });
}
export function filter(operation) {
    return createOperator('filter', getFunctionName(operation), (err, context, value, next, final) => {
        if (err)
            next(err, value);
        else if (operation(context, value))
            next(null, value);
        else
            final(null, value);
    });
}
let hasShownActionDeprecation = false;
export function action(operation) {
    if (!hasShownActionDeprecation) {
        console.warn(`DEPRECATION - The action operator is deprecated in favor of "mutate". The reason is to avoid confusion between actions and operators. Check out action "${getFunctionName(operation)}"`);
        hasShownActionDeprecation = true;
    }
    return createMutationOperator('action', getFunctionName(operation), (err, context, value, next) => {
        if (err)
            next(err, value);
        else {
            const result = operation(context, value);
            if (isPromise(result)) {
                next(null, result.then(() => value));
            }
            else {
                next(null, value);
            }
        }
    });
}
export function mutate(operation) {
    return createMutationOperator('mutate', getFunctionName(operation), (err, context, value, next) => {
        if (err)
            next(err, value);
        else {
            const result = operation(context, value);
            if (isPromise(result)) {
                next(null, result.then(() => value));
            }
            else {
                next(null, value);
            }
        }
    });
}
export function run(operation) {
    return createOperator('run', getFunctionName(operation), (err, context, value, next) => {
        if (err)
            next(err, value);
        else {
            const result = operation(context, value);
            if (isPromise(result)) {
                next(null, result.then(() => value));
            }
            else {
                next(null, value);
            }
        }
    });
}
export function catchError(operation) {
    return createMutationOperator('catchError', getFunctionName(operation), (err, context, value, next) => {
        if (err)
            next(null, operation(context, err));
        else
            next(null, value, {
                isSkipped: true,
            });
    });
}
export function tryCatch(paths) {
    const instance = (err, context, next) => {
        if (err)
            next(err, context);
        else {
            const evaluateCatch = (err, catchContext) => {
                operatorStopped(context, context.value);
                next(err, createContext(catchContext, context.value));
            };
            const evaluateTry = (err, tryContext) => {
                if (err) {
                    const newContext = createContext(tryContext, err, context.execution.path && context.execution.path.concat('catch'));
                    const nextWithPath = createNextPath(evaluateCatch);
                    // @ts-ignore
                    paths.catch(null, newContext, nextWithPath);
                }
                else {
                    operatorStopped(context, context.value);
                    next(null, createContext(tryContext, context.value));
                }
            };
            operatorStarted('tryCatch', '', context);
            const newContext = createContext(context, context.value, context.execution.path && context.execution.path.concat('try'));
            const nextWithPath = createNextPath(evaluateTry);
            // @ts-ignore
            paths.try(null, newContext, nextWithPath);
        }
    };
    instance[IS_OPERATOR] = true;
    return instance;
}
export function fork(operation, paths) {
    return createOperator('fork', getFunctionName(operation), (err, context, value, next) => {
        if (err)
            next(err, value);
        else {
            const path = operation(context, value);
            next(null, value, {
                path: {
                    name: String(path),
                    operator: paths[path],
                },
            });
        }
    });
}
export function when(operation, paths) {
    return createOperator('when', getFunctionName(operation), (err, context, value, next) => {
        if (err)
            next(err, value);
        else if (operation(context, value))
            next(null, value, {
                path: {
                    name: 'true',
                    operator: paths.true,
                },
            });
        else
            next(null, value, {
                path: {
                    name: 'false',
                    operator: paths.false,
                },
            });
    });
}
export function wait(ms) {
    return createOperator('wait', String(ms), (err, context, value, next) => {
        if (err)
            next(err, value);
        else
            setTimeout(() => next(null, value), ms);
    });
}
export function debounce(ms) {
    let timeout;
    let previousFinal;
    return createOperator('debounce', String(ms), (err, context, value, next, final) => {
        if (err)
            next(err, value);
        else {
            if (timeout) {
                clearTimeout(timeout);
                previousFinal(null, value);
            }
            previousFinal = final;
            timeout = setTimeout(() => {
                timeout = null;
                next(null, value);
            }, ms);
        }
    });
}
export function throttle(ms) {
    let timeout;
    let previousFinal;
    let currentNext;
    return createOperator('throttle', String(ms), (err, context, value, next, final) => {
        if (err)
            next(err, value);
        else {
            if (timeout) {
                previousFinal(null, value);
                currentNext = next;
            }
            else {
                timeout = setTimeout(() => {
                    timeout = null;
                    currentNext(null, value);
                }, ms);
            }
            previousFinal = final;
            currentNext = next;
        }
    });
}
export function waitUntil(operation) {
    return createOperator('waitUntil', operation.name, (err, context, value, next) => {
        if (err)
            next(err, value);
        else {
            const tree = context.execution.getTrackStateTree();
            const test = () => {
                if (operation(tree.state)) {
                    tree.dispose();
                    next(null, value);
                }
            };
            tree.trackScope(test, test);
        }
    });
}
//# sourceMappingURL=index.js.map