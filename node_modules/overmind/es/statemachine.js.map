{"version":3,"file":"statemachine.js","sourceRoot":"","sources":["../src/statemachine.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,UAAU,EAAE,KAAK,EAAE,MAAM,kBAAkB,CAAA;AAyBpD,MAAM,aAAa,GAAG,MAAM,CAAC,eAAe,CAAC,CAAA;AAC7C,MAAM,WAAW,GAAG,MAAM,CAAC,aAAa,CAAC,CAAA;AAEzC,MAAM,YAAY;IAGhB,YAAY,WAA4C,EAAE,UAAkB;QAC1E,IAAI,CAAC,aAAa,CAAC,GAAG,UAAU,CAAC,KAAK,CAAA;QACtC,IAAI,CAAC,WAAW,CAAC,GAAG,WAAW,CAAA;QAC/B,MAAM,CAAC,MAAM,CAAC,IAAI,EAAE,UAAU,CAAC,CAAA;IACjC,CAAC;IACD,UAAU,CAAC,KAAK;QACd,MAAM,WAAW,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,WAAW,CAAC,CAAA;QAC5C,IAAI,WAAW,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE;YAC3C,MAAM,IAAI,GAAG,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,MAAM,CAAC,YAAY,IAAI,IAAI,CAAC,UAAU,CAAC,CAAC,CAAA;YACvE,IAAI,CAAC,eAAe,EAAE,CAAA;YACtB,IAAI,CAAC,KAAK,GAAG,KAAK,CAAA;YAClB,OAAO,CAAC,OAAO,EAAE,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,cAAc,EAAE,CAAC,CAAA;YACnD,OAAO,IAAI,CAAA;SACZ;aAAM,IAAI,OAAO,CAAC,GAAG,CAAC,QAAQ,KAAK,aAAa,EAAE;YACjD,OAAO,CAAC,IAAI,CAAC,yDAAyD,KAAK,kEAAkE,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAA;SACxL;QACD,OAAO,KAAK,CAAA;IACd,CAAC;IACD,OAAO,CAAC,KAAK;QACX,IAAI,KAAK,KAAK,IAAI,CAAC,KAAK,EAAE;YACxB,MAAM,IAAI,GAAG,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,MAAM,CAAC,YAAY,IAAI,IAAI,CAAC,UAAU,CAAC,CAAC,CAAA;YACvE,IAAI,CAAC,eAAe,EAAE,CAAA;YACtB,OAAO,IAAI,CAAA;SACZ;QAED,OAAO,KAAK,CAAA;IACd,CAAC;CACF;AAED,MAAM,UAAU,YAAY,CAAyB,UAA2C,EAAE,KAAa;IAC7G,OAAO,IAAI,YAAY,CAAC,UAAU,EAAE,KAAK,CAAQ,CAAA;AACnD,CAAC","sourcesContent":["import { PROXY_TREE, VALUE } from 'proxy-state-tree'\n\nimport { IState } from '.'\n\ntype TStates = IState & {\n  state: string | number,\n}\n\nexport type StatemachineTransitions<States extends TStates> = {\n  [State in States[\"state\"]]: Array<States[\"state\"]>\n}\n\nexport interface MachineMethods<States extends TStates> {\n  matches<T extends States[\"state\"]>(state: T): this is Statemachine<States, States extends {\n    state: T;\n} ? States : never>;\n  transition<State extends States[\"state\"]>(\n    state: State,\n  ): this is Statemachine<States, States extends {\n    state: State\n} ? States : never>\n}\n\nexport type Statemachine<States extends TStates, State extends TStates = States> = State & MachineMethods<States>\n\nconst INITIAL_STATE = Symbol('INITIAL_STATE')\nconst TRANSITIONS = Symbol('TRANSITIONS')\n\nclass StateMachine<States extends TStates, State extends TStates = States>  {\n  state: State[\"state\"]\n  private [INITIAL_STATE]: State[\"state\"]\n  constructor(transitions: StatemachineTransitions<States>, definition: States) {\n    this[INITIAL_STATE] = definition.state\n    this[TRANSITIONS] = transitions\n    Object.assign(this, definition)\n  }\n  transition(state) {\n    const transitions = this[VALUE][TRANSITIONS]\n    if (transitions[this.state].includes(state)) {\n      const tree = (this[PROXY_TREE].master.mutationTree || this[PROXY_TREE])\n      tree.enableMutations()\n      this.state = state\n      Promise.resolve().then(() => tree.blockMutations())\n      return true\n    } else if (process.env.NODE_ENV === 'development') {\n      console.warn(`Overmind Statemachine - You tried to transition into \"${state}\", but it is not a valid transition. The valid transitions are ${JSON.stringify(transitions[this.state])}`)\n    }\n    return false\n  }\n  matches(state) {\n    if (state === this.state) {\n      const tree = (this[PROXY_TREE].master.mutationTree || this[PROXY_TREE])\n      tree.enableMutations()\n      return true\n    }\n\n    return false\n  }\n}\n\nexport function statemachine<States extends TStates>(definition: StatemachineTransitions<States>, state: States): Statemachine<States> {\n  return new StateMachine(definition, state) as any\n}\n"]}