import { EventEmitter } from 'betsy';
import { IFlushCallback, IMutation, IMutationCallback, IMutationTree, ITrackStateTree } from 'proxy-state-tree';
import { Devtools } from './Devtools';
import { DefaultMode, Events, NestedPartial, Options, ResolveActions, SSRMode, TestMode } from './internalTypes';
import { createMutationOperator, createOperator } from './operator';
import { IAction, IConfiguration, IContext, IOnInitialize, IOperator, IReaction, IState } from './types';
export * from './types';
export { createOperator, createMutationOperator, ResolveActions };
export { MODE_DEFAULT, MODE_TEST, MODE_SSR } from './utils';
export { SERIALIZE, rehydrate } from './rehydrate';
export { Statemachine, statemachine } from './statemachine';
export declare const derived: <S extends IState, R extends IState, O>(cb: (state: S, rootState: R) => O) => O;
/** This type can be overwriten by app developers if they want to avoid
 * typing and then they can import `Action`,  `Operation` etc. directly from
 * overmind.
 */
export interface Config {
}
export interface Context extends IContext<Config> {
}
export declare type RootState = Context["state"];
export interface Action<Value = void, ReturnValue = void> extends IAction<Config, Value, ReturnValue> {
}
export interface AsyncAction<Value = void, ReturnValue = void> extends IAction<Config, Value, Promise<ReturnValue>> {
}
export interface OnInitialize extends IOnInitialize<Config> {
}
export interface Reaction extends IReaction<Config> {
}
export { json } from './utils';
export interface OvermindSSR<Config extends IConfiguration> extends Overmind<Config> {
    hydrate(): IMutation[];
}
export declare function createOvermindSSR<Config extends IConfiguration>(config: Config): OvermindSSR<Config>;
export interface OvermindMock<Config extends IConfiguration> extends Overmind<Config> {
    onInitialize: () => Promise<IMutation[]>;
    mutations: IMutation[];
}
export declare function createOvermindMock<Config extends IConfiguration>(config: Config, mockedEffects?: NestedPartial<Config['effects']>): OvermindMock<Config>;
export declare function createOvermind<Config extends IConfiguration>(config: Config, options?: Options): Overmind<Config>;
export declare class Overmind<ThisConfig extends IConfiguration> implements IConfiguration {
    private proxyStateTree;
    private actionReferences;
    private nextExecutionId;
    private mode;
    private reydrateMutationsForHotReloading;
    private originalConfiguration;
    initialized: Promise<any>;
    eventHub: EventEmitter<Events>;
    devtools: Devtools;
    actions: ResolveActions<ThisConfig['actions']>;
    state: ThisConfig['state'];
    effects: ThisConfig['effects'] & {};
    delimiter: string;
    constructor(configuration: ThisConfig, options?: Options, mode?: DefaultMode | TestMode | SSRMode);
    private createProxyStateTree;
    private createExecution;
    private createContext;
    private scopeValue;
    private addExecutionMutation;
    private createAction;
    private trackEffects;
    private initializeDevtools;
    private getState;
    private getActions;
    private updateActions;
    getTrackStateTree(): ITrackStateTree<any>;
    getMutationTree(): IMutationTree<any>;
    reaction: IReaction<ThisConfig>;
    addMutationListener: (cb: IMutationCallback) => () => void;
    addFlushListener: (cb: IFlushCallback) => () => IFlushCallback[];
    reconfigure(configuration: IConfiguration): this;
}
export declare type Operator<Input = void, Output = Input> = IOperator<Config, Input, Output>;
export declare function pipe<ThisConfig extends IConfiguration, A, B, Output = B>(aOperator: IOperator<ThisConfig, A, B>): IOperator<ThisConfig, A, Output>;
export declare function pipe<ThisConfig extends IConfiguration, A, B, C, Output = C>(aOperator: IOperator<ThisConfig, A, B>, bOperator: IOperator<ThisConfig, B, C>): IOperator<ThisConfig, A, Output>;
export declare function pipe<ThisConfig extends IConfiguration, A, B, C, D, Output = D>(aOperator: IOperator<ThisConfig, A, B>, bOperator: IOperator<ThisConfig, B, C>, cOperator: IOperator<ThisConfig, C, D>): IOperator<ThisConfig, A, Output>;
export declare function pipe<ThisConfig extends IConfiguration, A, B, C, D, E, Output = E>(aOperator: IOperator<ThisConfig, A, B>, bOperator: IOperator<ThisConfig, B, C>, cOperator: IOperator<ThisConfig, C, D>, dOperator: IOperator<ThisConfig, D, E>): IOperator<ThisConfig, A, Output>;
export declare function pipe<ThisConfig extends IConfiguration, A, B, C, D, E, F, Output = F>(aOperator: IOperator<ThisConfig, A, B>, bOperator: IOperator<ThisConfig, B, C>, cOperator: IOperator<ThisConfig, C, D>, dOperator: IOperator<ThisConfig, D, E>, eOperator: IOperator<ThisConfig, E, F>): IOperator<ThisConfig, A, Output>;
export declare function pipe<ThisConfig extends IConfiguration, A, B, C, D, E, F, G, Output = G>(aOperator: IOperator<ThisConfig, A, B>, bOperator: IOperator<ThisConfig, B, C>, cOperator: IOperator<ThisConfig, C, D>, dOperator: IOperator<ThisConfig, D, E>, eOperator: IOperator<ThisConfig, E, F>, fOperator: IOperator<ThisConfig, F, G>): IOperator<ThisConfig, A, Output>;
export declare function pipe<ThisConfig extends IConfiguration, A, B, C, D, E, F, G, H, Output = H>(aOperator: IOperator<ThisConfig, A, B>, bOperator: IOperator<ThisConfig, B, C>, cOperator: IOperator<ThisConfig, C, D>, dOperator: IOperator<ThisConfig, D, E>, eOperator: IOperator<ThisConfig, E, F>, fOperator: IOperator<ThisConfig, F, G>, gOperator: IOperator<ThisConfig, G, H>): IOperator<ThisConfig, A, Output>;
export declare function pipe<ThisConfig extends IConfiguration, A, B, C, D, E, F, G, H, I>(aOperator: IOperator<ThisConfig, A, B>, bOperator: IOperator<ThisConfig, B, C>, cOperator: IOperator<ThisConfig, C, D>, dOperator: IOperator<ThisConfig, D, E>, eOperator: IOperator<ThisConfig, E, F>, fOperator: IOperator<ThisConfig, F, G>, gOperator: IOperator<ThisConfig, G, H>, hOperator: IOperator<ThisConfig, H, I>): IOperator<ThisConfig, A, I extends never ? any : I>;
export declare function pipe<ThisConfig extends IConfiguration, A, B, C, D, E, F, G, H, I, J>(aOperator: IOperator<ThisConfig, A, B>, bOperator: IOperator<ThisConfig, B, C>, cOperator: IOperator<ThisConfig, C, D>, dOperator: IOperator<ThisConfig, D, E>, eOperator: IOperator<ThisConfig, E, F>, fOperator: IOperator<ThisConfig, F, G>, gOperator: IOperator<ThisConfig, G, H>, hOperator: IOperator<ThisConfig, H, I>, iOperator: IOperator<ThisConfig, I, J>): IOperator<ThisConfig, A, J extends never ? any : J>;
export declare function pipe<ThisConfig extends IConfiguration, A, B, C, D, E, F, G, H, I, J, K>(aOperator: IOperator<ThisConfig, A, B>, bOperator: IOperator<ThisConfig, B, C>, cOperator: IOperator<ThisConfig, C, D>, dOperator: IOperator<ThisConfig, D, E>, eOperator: IOperator<ThisConfig, E, F>, fOperator: IOperator<ThisConfig, F, G>, gOperator: IOperator<ThisConfig, G, H>, hOperator: IOperator<ThisConfig, H, I>, iOperator: IOperator<ThisConfig, I, J>, jOperator: IOperator<ThisConfig, J, K>): IOperator<ThisConfig, A, K extends never ? any : K>;
export declare function forEach<Input extends any[], ThisConfig extends IConfiguration = Config>(forEachItemOperator: IOperator<ThisConfig, Input extends Array<infer U> ? U : never>): IOperator<ThisConfig, Input, Input>;
export declare function parallel<Input, ThisConfig extends IConfiguration = Config>(...operators: IOperator<ThisConfig, Input>[]): IOperator<ThisConfig, Input, Input>;
export declare function map<Input, Output, ThisConfig extends IConfiguration = Config>(operation: (context: IContext<ThisConfig>, value: Input) => Output): IOperator<ThisConfig, Input, Output extends Promise<infer U> ? U : Output>;
export declare function noop<Input, ThisConfig extends IConfiguration = Config>(): IOperator<ThisConfig, Input>;
export declare function filter<Input, ThisConfig extends IConfiguration = Config>(operation: (context: IContext<ThisConfig>, value: Input) => boolean): IOperator<ThisConfig, Input, Input>;
export declare function action<Input, ThisConfig extends IConfiguration = Config>(operation: (context: IContext<ThisConfig>, value: Input) => void): IOperator<ThisConfig, Input, Input>;
export declare function mutate<Input, ThisConfig extends IConfiguration = Config>(operation: (context: IContext<ThisConfig>, value: Input) => void): IOperator<ThisConfig, Input, Input>;
export declare function run<Input, ThisConfig extends IConfiguration = Config>(operation: (context: IContext<ThisConfig>, value: Input) => void): IOperator<ThisConfig, Input, Input>;
export declare function catchError<Input, ThisConfig extends IConfiguration = Config>(operation: (context: IContext<ThisConfig>, value: Error) => Input): IOperator<ThisConfig, Input, Input>;
export declare function tryCatch<Input, ThisConfig extends IConfiguration = Config>(paths: {
    try: IOperator<ThisConfig, Input>;
    catch: IOperator<ThisConfig, Error>;
}): IOperator<ThisConfig, Input, Input>;
export declare function fork<Input, Paths extends {
    [key: string]: IOperator<ThisConfig, any, any>;
}, ThisConfig extends IConfiguration = Config>(operation: (context: IContext<ThisConfig>, value: Input) => keyof Paths, paths: Paths & {
    [N in keyof Paths]: IOperator<ThisConfig, Input, any>;
}): IOperator<ThisConfig, Input, Input>;
export declare function when<Input, OutputA, OutputB, ThisConfig extends IConfiguration = Config>(operation: (context: IContext<ThisConfig>, value: Input) => boolean, paths: {
    true: IOperator<ThisConfig, Input, OutputA>;
    false: IOperator<ThisConfig, Input, OutputB>;
}): IOperator<ThisConfig, Input, OutputA | OutputB>;
export declare function wait<Input, ThisConfig extends IConfiguration = Config>(ms: number): IOperator<ThisConfig, Input, Input>;
export declare function debounce<Input, ThisConfig extends IConfiguration = Config>(ms: number): IOperator<ThisConfig, Input, Input>;
export declare function throttle<Input, ThisConfig extends IConfiguration = Config>(ms: number): IOperator<ThisConfig, Input, Input>;
export declare function waitUntil<Input, ThisConfig extends IConfiguration = Config>(operation: (state: ThisConfig['state']) => boolean): IOperator<ThisConfig, Input, Input>;
