"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const is_plain_obj_1 = tslib_1.__importDefault(require("is-plain-obj"));
const proxy_state_tree_1 = require("proxy-state-tree");
exports.IS_TEST = process.env.NODE_ENV === 'test';
exports.IS_OPERATOR = Symbol('operator');
exports.ORIGINAL_ACTIONS = Symbol('origina_actions');
exports.EXECUTION = Symbol('execution');
exports.MODE_DEFAULT = Symbol('MODE_DEFAULT');
exports.MODE_TEST = Symbol('MODE_TEST');
exports.MODE_SSR = Symbol('MODE_SSR');
class MockedEventEmitter {
    emit() { }
    emitAsync() { }
    on() { }
    once() { }
    addListener() { }
}
exports.MockedEventEmitter = MockedEventEmitter;
exports.json = (obj) => {
    return deepCopy(obj && obj[proxy_state_tree_1.IS_PROXY] ? obj[proxy_state_tree_1.VALUE] : obj);
};
function isPromise(maybePromise) {
    return (maybePromise instanceof Promise ||
        (maybePromise &&
            typeof maybePromise.then === 'function' &&
            typeof maybePromise.catch === 'function'));
}
exports.isPromise = isPromise;
function processState(state) {
    return Object.keys(state).reduce((aggr, key) => {
        if (key === '__esModule') {
            return aggr;
        }
        const originalDescriptor = Object.getOwnPropertyDescriptor(state, key);
        if (originalDescriptor && 'get' in originalDescriptor) {
            Object.defineProperty(aggr, key, originalDescriptor);
            return aggr;
        }
        const value = state[key];
        if (is_plain_obj_1.default(value)) {
            aggr[key] = processState(value);
        }
        else {
            Object.defineProperty(aggr, key, originalDescriptor);
        }
        return aggr;
    }, is_plain_obj_1.default(state) ? {} : state);
}
exports.processState = processState;
function getFunctionName(func) {
    return func.name || func.displayName || '';
}
exports.getFunctionName = getFunctionName;
function deepCopy(obj) {
    if (is_plain_obj_1.default(obj)) {
        return Object.keys(obj).reduce((aggr, key) => {
            if (key === '__esModule') {
                return aggr;
            }
            const originalDescriptor = Object.getOwnPropertyDescriptor(obj, key);
            const isAGetter = originalDescriptor && 'get' in originalDescriptor;
            const value = obj[key];
            if (isAGetter) {
                Object.defineProperty(aggr, key, originalDescriptor);
            }
            else {
                aggr[key] = deepCopy(value);
            }
            return aggr;
        }, {});
    }
    else if (Array.isArray(obj)) {
        return obj.map((item) => deepCopy(item));
    }
    return obj;
}
exports.deepCopy = deepCopy;
const getChangeMutationsDelimiter = '.';
function getChangeMutations(stateA, stateB, path = [], mutations = []) {
    const stateAKeys = Object.keys(stateA);
    const stateBKeys = Object.keys(stateB);
    stateAKeys.forEach((key) => {
        if (!stateBKeys.includes(key)) {
            mutations.push({
                delimiter: getChangeMutationsDelimiter,
                args: [],
                path: path.concat(key).join('.'),
                hasChangedValue: false,
                method: 'unset',
            });
        }
    });
    stateBKeys.forEach((key) => {
        if (is_plain_obj_1.default(stateA[key]) && is_plain_obj_1.default(stateB[key])) {
            getChangeMutations(stateA[key], stateB[key], path.concat(key), mutations);
        }
        else if (stateA[key] !== stateB[key]) {
            mutations.push({
                delimiter: getChangeMutationsDelimiter,
                args: [stateB[key]],
                path: path.concat(key).join('.'),
                hasChangedValue: false,
                method: 'set'
            });
        }
    });
    return mutations;
}
exports.getChangeMutations = getChangeMutations;
function getActionPaths(actions = {}, currentPath = []) {
    return Object.keys(actions).reduce((aggr, key) => {
        if (typeof actions[key] === 'function') {
            return aggr.concat(currentPath.concat(key).join('.'));
        }
        return aggr.concat(getActionPaths(actions[key], currentPath.concat(key)));
    }, []);
}
exports.getActionPaths = getActionPaths;
function createActionsProxy(actions, cb) {
    return new Proxy(actions, {
        get(target, prop) {
            if (prop === exports.ORIGINAL_ACTIONS) {
                return actions;
            }
            if (typeof target[prop] === 'function') {
                return cb(target[prop]);
            }
            if (!target[prop]) {
                return undefined;
            }
            return createActionsProxy(target[prop], cb);
        },
    });
}
exports.createActionsProxy = createActionsProxy;
//# sourceMappingURL=utils.js.map