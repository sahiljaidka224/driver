{"version":3,"file":"lazy.js","sourceRoot":"","sources":["../../src/config/lazy.ts"],"names":[],"mappings":";;;AAEA,6CAAyC;AACzC,oCAAuC;AAYvC,SAAgB,IAAI,CAClB,cAAiB;IA0CjB,IAAI,GAAG,CAAA;IACP,OAAO;QACL,YAAY,CAAC,CAAC,EAAE,KAAK;YACnB,GAAG,GAAG,KAAK,CAAA;QACb,CAAC;QACD,OAAO,EAAE;YACP,IAAI,EAAE;gBACJ,UAAU,CAAC,MAAM;oBACf,OAAO,GAAG,CAAC,OAAO,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,CAAA;gBAC5C,CAAC;aACF;SACF;QACD,OAAO,EAAE;YACP,IAAI,EAAE;gBACJ,UAAU,CAAC,EAAkB,EAAE,GAAG;wBAAvB,EAAE,KAAK,OAAW,EAAT,oCAAO;oBACzB,MAAM,YAAY,GAAG,cAAc,CAAC,GAAG,CAAC,CAAA;oBAExC,OAAO,YAAY,EAAE,CAAC,IAAI,CAAC,CAAC,YAAY,EAAE,EAAE;wBAC1C,MAAM,SAAS,GAAG,uBAAU,CAAC;4BAC3B,CAAC,GAAG,CAAC,EAAE,YAAY;yBACpB,CAAC,CAAA;wBAEF,IAAI,SAAS,CAAC,KAAK,IAAI,SAAS,CAAC,KAAK,CAAC,GAAG,CAAC;4BACzC,KAAK,CAAC,GAAG,CAAC,GAAG,oBAAY,CAAC,SAAS,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAA;wBACjD,IAAI,SAAS,CAAC,OAAO,IAAI,SAAS,CAAC,OAAO,CAAC,GAAG,CAAC;4BAC7C,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,SAAS,CAAC,OAAO,CAAC,GAAG,CAAC,CAAA;wBAC3C,IAAI,SAAS,CAAC,OAAO,IAAI,SAAS,CAAC,OAAO,CAAC,GAAG,CAAC;4BAC7C,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC,UAAU,CAAC,SAAS,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAA;wBAC3D,IAAI,SAAS,CAAC,YAAY;4BACxB,SAAS,CAAC,YAAY,iBAElB,KAAK,IACF,IAAI,GAET,GAAG,CACJ,CAAA;oBACL,CAAC,CAAC,CAAA;gBACJ,CAAC;aACF;SACF;KACK,CAAA;AACV,CAAC;AApFD,oBAoFC","sourcesContent":["import { SubType } from '../internalTypes'\nimport { IAction } from '..'\nimport { namespaced } from './namespaced'\nimport { processState } from '../utils'\n\ninterface LazyConfiguration {\n  [namespace: string]: () => Promise<{\n    onInitialize?: any\n    state?: {}\n    effects?: {}\n    actions?: {}\n    reactions?: {}\n  }>\n}\n\nexport function lazy<T extends LazyConfiguration, B = T>(\n  configurations: T\n): {\n  onInitialize?: any\n  state: SubType<\n    {\n      [P in keyof T]?: ReturnType<T[P]> extends Promise<infer U>\n        ? U extends { state: any }\n          ? U['state']\n          : never\n        : never\n    },\n    object\n  >\n  effects: SubType<\n    {\n      [P in keyof T]?: ReturnType<T[P]> extends Promise<infer U>\n        ? U extends { effects: any }\n          ? U['effects']\n          : never\n        : never\n    },\n    object\n  > & {\n    lazy: {\n      loadConfig: (config: keyof T) => Promise<void>\n    }\n  }\n  actions: SubType<\n    {\n      [P in keyof T]?: ReturnType<T[P]> extends Promise<infer U>\n        ? U extends { actions: any }\n          ? U['actions']\n          : never\n        : never\n    },\n    object\n  > & {\n    lazy: {\n      loadConfig: IAction<any, keyof T>\n    }\n  }\n} {\n  let app\n  return {\n    onInitialize(_, value) {\n      app = value\n    },\n    effects: {\n      lazy: {\n        loadConfig(config) {\n          return app.actions.lazy.loadConfig(config)\n        },\n      },\n    },\n    actions: {\n      lazy: {\n        loadConfig({ state, ...rest }, key) {\n          const configToLoad = configurations[key]\n\n          return configToLoad().then((loadedConfig) => {\n            const newConfig = namespaced({\n              [key]: loadedConfig,\n            })\n\n            if (newConfig.state && newConfig.state[key])\n              state[key] = processState(newConfig.state[key])\n            if (newConfig.effects && newConfig.effects[key])\n              app.effects[key] = newConfig.effects[key]\n            if (newConfig.actions && newConfig.actions[key])\n              app.actions[key] = app.getActions(newConfig.actions[key])\n            if (newConfig.onInitialize)\n              newConfig.onInitialize(\n                {\n                  state,\n                  ...rest,\n                },\n                app\n              )\n          })\n        },\n      },\n    },\n  } as any\n}\n"]}