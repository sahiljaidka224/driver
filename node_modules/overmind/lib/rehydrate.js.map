{"version":3,"file":"rehydrate.js","sourceRoot":"","sources":["../src/rehydrate.ts"],"names":[],"mappings":"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","sourcesContent":["import { IMutation } from 'proxy-state-tree'\n\nexport function rehydrateState(target: any, source: any, classes: any = {}) {\n  if (!target || !source) {\n    throw new Error(`You have to pass a \"target\" and \"source\" object to rehydrate`)\n  }\n\n  Object.keys(source).forEach((key) => {\n    const value = source[key]\n    const classInstance = classes[key]\n    \n    if (typeof classInstance === 'function' && Array.isArray(target[key])) {\n      target[key] = (source[key] as any[]).map(value => classInstance(value))\n    } else if (typeof classInstance === 'function' && typeof target[key] === 'object' && target[key] !== null && target[key].constructor.name === 'Object') {\n      target[key] = Object.keys(source[key] as any).reduce((aggr, subKey) => {\n        aggr[subKey] = classInstance((source[key] as any)[subKey])\n        \n        return aggr\n      }, {})\n    } else if (typeof classInstance === 'function') {\n      target[key] = classInstance(source[key])\n    } else if (typeof value === 'object' && !Array.isArray(value) && value !== null) {\n      if (!target[key]) target[key] = {}\n      rehydrateState(target[key], source[key], classes[key])\n    } else {\n      target[key] = source[key]\n    }\n  })\n}\n\nexport const SERIALIZE = Symbol('SERIALIZE')\n\nexport interface Serialize {\n  [SERIALIZE]: boolean\n} \n\nexport type Serializable = Serialize | {\n  toJSON: () => {\n    [SERIALIZE]: boolean\n  }\n}\n\ntype SerializableValue = Serializable | Array<Serializable> | { [key: string]: Serializable } | null\n\ntype FilteredKeys<T, U> = { [P in keyof T]: T[P] extends U ? P : never }[keyof T];\n\ntype ExcludeNever<T extends {}> = { [P in keyof T]: T[P] extends never ? never : P }[keyof T]\n\ntype ExtracType<\n    T extends {},\n    K\n> = {\n    [P in FilteredKeys<T, K | {}>]:\n        T[P] extends SerializableValue ? (data: any) => Serializable :\n        T[P] extends {} ? ExtracType<T[P], K> extends { [key: string]: never } ? never : ExtractDeepType<T[P], K>  : never\n    }\n\ntype ExtractDeepType<T extends {}, K, U = ExtracType<T, K>> = {\n    [P in ExcludeNever<U>]: U[P]\n}\n\ntype StateNode = {\n  [key: string]: any\n}\n\nexport const rehydrate = <T extends StateNode>(state: T, source: IMutation[] | StateNode, classes: ExtractDeepType<T, SerializableValue> = {} as any) => {\n  if (Array.isArray(source)) {\n    const mutations = source as IMutation[]\n    mutations.forEach((mutation) => {\n      const pathArray = mutation.path.split(mutation.delimiter)\n      const key = pathArray.pop() as string\n      const target = pathArray.reduce((aggr, key) => aggr[key], state as any)\n      const classInstance = pathArray.reduce((aggr, key) => aggr && aggr[key], classes as any)\n  \n      if (mutation.method === 'set') {\n        if (typeof classInstance === 'function' && Array.isArray(mutation.args[0])) {\n          target[key] = mutation.args[0].map((arg) => classInstance(arg))\n        } else if (typeof classInstance === 'function') {\n          target[key] = classInstance(mutation.args[0])\n        } else {\n          target[key] = mutation.args[0]\n        }\n      } else if (mutation.method === 'unset') {\n        delete target[key]\n      } else {\n        target[key][mutation.method].apply(target[key], typeof classInstance === 'function' ? mutation.args.map((arg) => {\n          return typeof arg === 'object' && arg !== null ? classInstance(arg) : arg\n        }) : mutation.args)\n      }\n    })\n  } else {\n    rehydrateState(state, source, classes)\n  } \n}"]}