{"version":3,"file":"internalTypes.js","sourceRoot":"","sources":["../src/internalTypes.ts"],"names":[],"mappings":";;AAiDA,IAAY,SAcX;AAdD,WAAY,SAAS;IACnB,0CAA6B,CAAA;IAC7B,sCAAyB,CAAA;IACzB,8CAAiC,CAAA;IACjC,0CAA6B,CAAA;IAC7B,8CAAiC,CAAA;IACjC,oCAAuB,CAAA;IACvB,8BAAiB,CAAA;IACjB,gCAAmB,CAAA;IACnB,4CAA+B,CAAA;IAC/B,4CAA+B,CAAA;IAC/B,kDAAqC,CAAA;IACrC,kDAAqC,CAAA;IACrC,8BAAiB,CAAA;AACnB,CAAC,EAdW,SAAS,GAAT,iBAAS,KAAT,iBAAS,QAcpB","sourcesContent":["import {\n  IFlushCallback,\n  IMutation,\n  IMutationTree,\n  ITrackStateTree,\n} from 'proxy-state-tree'\n\nimport { IAction,  IOperator, IState } from './types'\n\nexport type SubType<Base, Condition> = Pick<\n  Base,\n  { [Key in keyof Base]: Base[Key] extends Condition ? Key : never }[keyof Base]\n>\n\nexport type NestedPartial<T> = T extends Function\n  ? T\n  : Partial<{ [P in keyof T]: NestedPartial<T[P]> }>\n\n\nexport type Options = {\n  delimiter?: string\n  name?: string\n  devtools?: string | boolean\n  logProxies?: boolean\n  hotReloading?: boolean\n}\n\nexport type DefaultMode = {\n  mode: Symbol\n}\n\nexport type TestMode = {\n  mode: Symbol\n  options: {\n    effectsCallback: (\n      effect: {\n        effectId: number\n        name: string\n        method: string\n        args: any[]\n      }\n    ) => {}\n  }\n}\n\nexport type SSRMode = {\n  mode: Symbol\n}\n\nexport enum EventType {\n  ACTION_START = 'action:start',\n  ACTION_END = 'action:end',\n  OPERATOR_START = 'operator:start',\n  OPERATOR_END = 'operator:end',\n  OPERATOR_ASYNC = 'operator:async',\n  MUTATIONS = 'mutations',\n  EFFECT = 'effect',\n  DERIVED = 'derived',\n  DERIVED_DIRTY = 'derived:dirty',\n  COMPONENT_ADD = 'component:add',\n  COMPONENT_UPDATE = 'component:update',\n  COMPONENT_REMOVE = 'component:remove',\n  GETTER = 'getter',\n}\n\nexport type Execution = {\n  actionId: number\n  executionId: number\n  actionName: string\n  operatorId: number\n  isRunning: boolean\n  parentExecution?: Execution\n  path: string[]\n  emit(event: EventType, value: any): void\n  flush(\n    isAsync?: boolean\n  ): {\n    mutations: IMutation[]\n    flushId: number\n  }\n  getMutationTree(): IMutationTree<any>\n  getTrackStateTree(): ITrackStateTree<any>\n  onFlush(cb: IFlushCallback): () => IFlushCallback[]\n  value?: any\n  error?: string\n}\n\nexport interface Events {\n  [EventType.ACTION_START]: Execution\n  [EventType.ACTION_END]: Execution\n  [EventType.OPERATOR_START]: Execution & {\n    path: string[]\n    type: string\n    name?: string\n  }\n  [EventType.OPERATOR_END]: Execution & {\n    path: string[]\n    isAsync: boolean\n    result: any\n  }\n  [EventType.OPERATOR_ASYNC]: Execution & {\n    path: string[]\n    type: string\n    name?: string\n  }\n  [EventType.MUTATIONS]: Execution & {\n    mutations: IMutation[]\n  }\n  [EventType.DERIVED]: {\n    path: string\n    paths: string[]\n    updateCount: number\n    value: any\n  }\n  [EventType.DERIVED_DIRTY]: {\n    derivedPath: string[]\n    path: string\n    flushId: number\n  }\n  [EventType.EFFECT]: Execution & {\n    result: any\n    name: string\n    method: string\n    args: any[]\n    isPending: boolean\n    error: string\n    effectId: number\n  }\n  [EventType.GETTER]: {\n    path: string\n    value: any\n  }\n  [EventType.COMPONENT_ADD]: {\n    componentId: number | string\n    componentInstanceId: number\n    name: string\n    paths: string[]\n  }\n  [EventType.COMPONENT_UPDATE]: {\n    componentId: number | string\n    componentInstanceId: number\n    name: string\n    paths: string[]\n    flushId?: number\n  }\n  [EventType.COMPONENT_REMOVE]: {\n    componentId: number | string\n    componentInstanceId: number\n    name: string\n  }\n}\n\n// ============= PRIVATE TYPES FOR APP\n\ntype NestedActions =\n  | {\n      [key: string]:\n        | IAction<any, any, any>\n        | IOperator<any, any, any>\n        | NestedActions\n    }\n  | undefined\n\ntype TActionValue<T> = T extends (a1: any, a2: infer TValue) => any\n  ? TValue\n  : never\n\nexport type ResolveActions<\n  Actions extends NestedActions\n> = Actions extends undefined\n  ? {}\n  : {\n      [T in keyof Actions]: Actions[T] extends IOperator<any, any, any>\n        ? TActionValue<Actions[T]> extends void\n          ? () => Promise<void>\n          : (value: TActionValue<Actions[T]>) => Promise<void>\n        : Actions[T] extends IAction<any, any, any>\n        ? TActionValue<Actions[T]> extends void\n          ? () => ReturnType<Actions[T]>\n          : (value: TActionValue<Actions[T]>) => ReturnType<Actions[T]>\n        : Actions[T] extends NestedActions\n        ? ResolveActions<Actions[T]>\n        : unknown\n    }\n\ntype NestedMockActions =\n  | {\n      [key: string]:\n        | IAction<any, any, any>\n        | IOperator<any, any, any>\n        | NestedMockActions\n    }\n  | undefined\n\ntype MockResult = IMutation[]\n\nexport type ResolveMockActions<\n  Actions extends NestedMockActions\n> = Actions extends undefined\n  ? {}\n  : {\n      [T in keyof Actions]: Actions[T] extends IOperator<any, any, any>\n        ? TActionValue<Actions[T]> extends void\n          ? () => Promise<MockResult>\n          : (value: TActionValue<Actions[T]>) => Promise<MockResult>\n        : Actions[T] extends IAction<any, any, any>\n        ? TActionValue<Actions[T]> extends void\n          ? () => Promise<MockResult>\n          : (value: TActionValue<Actions[T]>) => Promise<MockResult>\n        : Actions[T] extends NestedMockActions\n        ? ResolveMockActions<Actions[T]>\n        : unknown\n    }\n"]}