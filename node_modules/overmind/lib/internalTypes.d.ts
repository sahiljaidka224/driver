import { IFlushCallback, IMutation, IMutationTree, ITrackStateTree } from 'proxy-state-tree';
import { IAction, IOperator } from './types';
export declare type SubType<Base, Condition> = Pick<Base, {
    [Key in keyof Base]: Base[Key] extends Condition ? Key : never;
}[keyof Base]>;
export declare type NestedPartial<T> = T extends Function ? T : Partial<{
    [P in keyof T]: NestedPartial<T[P]>;
}>;
export declare type Options = {
    delimiter?: string;
    name?: string;
    devtools?: string | boolean;
    logProxies?: boolean;
    hotReloading?: boolean;
};
export declare type DefaultMode = {
    mode: Symbol;
};
export declare type TestMode = {
    mode: Symbol;
    options: {
        effectsCallback: (effect: {
            effectId: number;
            name: string;
            method: string;
            args: any[];
        }) => {};
    };
};
export declare type SSRMode = {
    mode: Symbol;
};
export declare enum EventType {
    ACTION_START = "action:start",
    ACTION_END = "action:end",
    OPERATOR_START = "operator:start",
    OPERATOR_END = "operator:end",
    OPERATOR_ASYNC = "operator:async",
    MUTATIONS = "mutations",
    EFFECT = "effect",
    DERIVED = "derived",
    DERIVED_DIRTY = "derived:dirty",
    COMPONENT_ADD = "component:add",
    COMPONENT_UPDATE = "component:update",
    COMPONENT_REMOVE = "component:remove",
    GETTER = "getter"
}
export declare type Execution = {
    actionId: number;
    executionId: number;
    actionName: string;
    operatorId: number;
    isRunning: boolean;
    parentExecution?: Execution;
    path: string[];
    emit(event: EventType, value: any): void;
    flush(isAsync?: boolean): {
        mutations: IMutation[];
        flushId: number;
    };
    getMutationTree(): IMutationTree<any>;
    getTrackStateTree(): ITrackStateTree<any>;
    onFlush(cb: IFlushCallback): () => IFlushCallback[];
    value?: any;
    error?: string;
};
export interface Events {
    [EventType.ACTION_START]: Execution;
    [EventType.ACTION_END]: Execution;
    [EventType.OPERATOR_START]: Execution & {
        path: string[];
        type: string;
        name?: string;
    };
    [EventType.OPERATOR_END]: Execution & {
        path: string[];
        isAsync: boolean;
        result: any;
    };
    [EventType.OPERATOR_ASYNC]: Execution & {
        path: string[];
        type: string;
        name?: string;
    };
    [EventType.MUTATIONS]: Execution & {
        mutations: IMutation[];
    };
    [EventType.DERIVED]: {
        path: string;
        paths: string[];
        updateCount: number;
        value: any;
    };
    [EventType.DERIVED_DIRTY]: {
        derivedPath: string[];
        path: string;
        flushId: number;
    };
    [EventType.EFFECT]: Execution & {
        result: any;
        name: string;
        method: string;
        args: any[];
        isPending: boolean;
        error: string;
        effectId: number;
    };
    [EventType.GETTER]: {
        path: string;
        value: any;
    };
    [EventType.COMPONENT_ADD]: {
        componentId: number | string;
        componentInstanceId: number;
        name: string;
        paths: string[];
    };
    [EventType.COMPONENT_UPDATE]: {
        componentId: number | string;
        componentInstanceId: number;
        name: string;
        paths: string[];
        flushId?: number;
    };
    [EventType.COMPONENT_REMOVE]: {
        componentId: number | string;
        componentInstanceId: number;
        name: string;
    };
}
declare type NestedActions = {
    [key: string]: IAction<any, any, any> | IOperator<any, any, any> | NestedActions;
} | undefined;
declare type TActionValue<T> = T extends (a1: any, a2: infer TValue) => any ? TValue : never;
export declare type ResolveActions<Actions extends NestedActions> = Actions extends undefined ? {} : {
    [T in keyof Actions]: Actions[T] extends IOperator<any, any, any> ? TActionValue<Actions[T]> extends void ? () => Promise<void> : (value: TActionValue<Actions[T]>) => Promise<void> : Actions[T] extends IAction<any, any, any> ? TActionValue<Actions[T]> extends void ? () => ReturnType<Actions[T]> : (value: TActionValue<Actions[T]>) => ReturnType<Actions[T]> : Actions[T] extends NestedActions ? ResolveActions<Actions[T]> : unknown;
};
declare type NestedMockActions = {
    [key: string]: IAction<any, any, any> | IOperator<any, any, any> | NestedMockActions;
} | undefined;
declare type MockResult = IMutation[];
export declare type ResolveMockActions<Actions extends NestedMockActions> = Actions extends undefined ? {} : {
    [T in keyof Actions]: Actions[T] extends IOperator<any, any, any> ? TActionValue<Actions[T]> extends void ? () => Promise<MockResult> : (value: TActionValue<Actions[T]>) => Promise<MockResult> : Actions[T] extends IAction<any, any, any> ? TActionValue<Actions[T]> extends void ? () => Promise<MockResult> : (value: TActionValue<Actions[T]>) => Promise<MockResult> : Actions[T] extends NestedMockActions ? ResolveMockActions<Actions[T]> : unknown;
};
export {};
