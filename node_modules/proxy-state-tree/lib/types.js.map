{"version":3,"file":"types.js","sourceRoot":"","sources":["../src/types.ts"],"names":[],"mappings":"","sourcesContent":["export interface IProxifier<T extends object> {\n  proxify(state: T, path: string): T\n  trackPath(path: string): void\n}\n\nexport interface IMutation {\n  method: string\n  delimiter: string\n  path: string\n  args: any[]\n  hasChangedValue: boolean\n}\n\nexport interface IMutationCallback {\n  (mutation: IMutation, paths: Set<string>, flushId: number): void\n}\n\nexport interface IMutationTree<T extends object> {\n  addMutation(mutation: IMutation, objectChangePath?: string): void\n  onMutation(callback: IMutationCallback): void\n  canTrack(): boolean\n  canMutate(): boolean\n  getMutations(): IMutation[]\n  getObjectChanges(): Set<string>\n  trackPaths(): () => Set<string>\n  flush(\n    async?: boolean\n  ): {\n    mutations: IMutation[]\n    flushId: number\n  }\n  dispose(): IMutationTree<T>\n  objectChanges: Set<string>\n  master: IProxyStateTree<T>\n  proxifier: IProxifier<T>\n  mutations: IMutation[]\n  state: T\n  trackPathListeners: Array<(path: string) => void>\n}\n\nexport interface ITrackCallback {\n  (\n    mutations: IMutation[],\n    paths: Array<string>,\n    flushId: number,\n    isAsync: boolean\n  ): void\n}\n\nexport interface ITrackScopedCallback<T extends object> {\n  (tree: ITrackStateTree<T>): any\n}\n\nexport interface ITrackStateTree<T extends object> {\n  addTrackingPath(path: string): void\n  track(cb?: ITrackCallback): ITrackStateTree<T>\n  stopTracking(): void\n  trackScope(scope: ITrackScopedCallback<T>, callback?: ITrackCallback): any\n  trackPaths(): () => Set<string>\n  canTrack(): boolean\n  canMutate(): boolean\n  dispose(): ITrackStateTree<T>\n  clearTracking(): void\n  master: IProxyStateTree<T>\n  shouldTrack: boolean\n  proxifier: IProxifier<T>\n  state: T\n  pathDependencies: Set<string>\n  callback: ITrackCallback\n  trackPathListeners: Array<(path: string) => void>\n}\n\nexport interface IOptions {\n  delimiter?: string\n  devmode?: boolean\n  onFunction?: (...args: any[]) => { func: Function, value: any } \n  onGetter?: Function\n}\n\nexport interface IFlushCallback {\n  (\n    mutations: IMutation[],\n    paths: string[],\n    flushId: number,\n    isAsync: boolean\n  ): void\n}\n\nexport type TTree = IMutationTree<any> | ITrackStateTree<any>\n\nexport interface IRemoveProxyCallback {\n  (path: string): void\n}\n\nexport interface IProxyStateTree<T extends object> {\n  addPathDependency(path: string, callback: ITrackCallback): void\n  removePathDependency(path: string, callback: ITrackCallback): void\n  getTrackStateTree(): ITrackStateTree<T>\n  getMutationTree(): IMutationTree<T>\n  changeTrackStateTree(tree: ITrackStateTree<T>): void\n  disposeTree(proxy: TTree): void\n  onMutation(cb: IMutationCallback): void\n  flush(\n    tree: IMutationTree<T>,\n    isAsync: boolean\n  ): {\n    mutations: IMutation[]\n    flushId: number\n  }\n  flush(\n    trees: IMutationTree<T>[],\n    isAsync: boolean\n  ): {\n    mutations: IMutation[]\n    flushId: number\n  }\n  onFlush(cb: IFlushCallback): void\n  rescope(value: any, tree: TTree): any\n  sourceState: T\n  state: T\n  options: IOptions\n  pathDependencies: {\n    [path: string]: Set<ITrackCallback>\n  }\n  master: IProxyStateTree<T>\n  proxifier: IProxifier<T>\n  currentTree: TTree\n  previousTree: TTree\n  mutationTree: IMutationTree<T>\n  mutationCallbacks: IMutationCallback[]\n  flushCallbacks: IFlushCallback[]\n  currentFlushId: number\n}\n"]}