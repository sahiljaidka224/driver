"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Proxyfier_1 = require("./Proxyfier");
class MutationTree {
    constructor(master, proxifier) {
        this.mutationCallbacks = [];
        this.mutations = [];
        this.objectChanges = new Set();
        this.isTracking = false;
        this.isBlocking = false;
        this.trackPathListeners = [];
        this.isTracking = true;
        this.master = master;
        this.proxifier = proxifier || new Proxyfier_1.Proxifier(this);
        this.state = this.proxifier.proxify(master.sourceState, '');
    }
    trackPaths() {
        const paths = new Set();
        const listener = (path) => {
            paths.add(path);
        };
        this.trackPathListeners.push(listener);
        return () => {
            this.trackPathListeners.splice(this.trackPathListeners.indexOf(listener), 1);
            return paths;
        };
    }
    getMutations() {
        const mutations = this.mutations.slice();
        this.mutations.length = 0;
        return mutations;
    }
    getObjectChanges() {
        const objectChanges = new Set([...this.objectChanges]);
        this.objectChanges.clear();
        return objectChanges;
    }
    addMutation(mutation, objectChangePath) {
        const currentFlushId = this.master.currentFlushId;
        this.mutations.push(mutation);
        if (objectChangePath) {
            this.objectChanges.add(objectChangePath);
        }
        for (let cb of this.master.mutationCallbacks) {
            cb(mutation, new Set(objectChangePath ? [mutation.path, objectChangePath] : [mutation.path]), currentFlushId);
        }
        for (let callback of this.mutationCallbacks) {
            callback(mutation, new Set(objectChangePath ? [mutation.path, objectChangePath] : [mutation.path]), currentFlushId);
        }
    }
    flush(isAsync = false) {
        return this.master.flush(this, isAsync);
    }
    onMutation(callback) {
        this.mutationCallbacks.push(callback);
    }
    canMutate() {
        return this.isTracking && !this.isBlocking;
    }
    canTrack() {
        return false;
    }
    blockMutations() {
        this.isBlocking = true;
    }
    enableMutations() {
        this.isBlocking = false;
    }
    dispose() {
        this.isTracking = false;
        this.mutationCallbacks.length = 0;
        this.proxifier = this.master.proxifier;
        return this;
    }
}
exports.MutationTree = MutationTree;
//# sourceMappingURL=MutationTree.js.map