import { MutationTree } from './MutationTree';
import { IS_PROXY, PATH, PROXY_TREE, VALUE } from './Proxyfier';
import { TrackStateTree } from './TrackStateTree';
import { IFlushCallback, IMutation, IMutationCallback, IMutationTree, IOptions, IProxifier, IProxyStateTree, ITrackCallback, ITrackStateTree, TTree } from './types';
export { IS_PROXY, PROXY_TREE, VALUE, PATH, IMutation, ITrackCallback, ITrackStateTree, IMutationTree, TrackStateTree, MutationTree, };
export * from './types';
export declare class ProxyStateTree<T extends object> implements IProxyStateTree<T> {
    private cache;
    flushCallbacks: IFlushCallback[];
    mutationCallbacks: IMutationCallback[];
    currentFlushId: number;
    currentTree: TTree;
    previousTree: TTree;
    mutationTree: IMutationTree<T>;
    proxifier: IProxifier<T>;
    master: ProxyStateTree<T>;
    pathDependencies: {
        [path: string]: Set<ITrackCallback>;
    };
    state: T;
    sourceState: T;
    options: IOptions;
    constructor(state: T, options?: IOptions);
    private createTrackStateProxifier;
    getMutationTree(): IMutationTree<T>;
    getTrackStateTree(): ITrackStateTree<T>;
    getTrackStateTreeWithProxifier(): ITrackStateTree<T>;
    changeTrackStateTree(tree: ITrackStateTree<T>): void;
    disposeTree(tree: TTree): void;
    onMutation(callback: IMutationCallback): () => void;
    forceFlush(): void;
    flush(trees: any, isAsync?: boolean): {
        mutations: any;
        flushId: number;
    };
    onFlush(callback: IFlushCallback): () => IFlushCallback[];
    rescope(value: any, tree: TTree): any;
    addPathDependency(path: string, callback: ITrackCallback): void;
    removePathDependency(path: string, callback: ITrackCallback): void;
    toJSON(): T;
}
