"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("proxy-state-tree");
const scheduler_1 = require("scheduler");
const overmind_1 = require("overmind");
const react = require("react");
const IS_PRODUCTION = process.env.NODE_ENV === 'production';
const IS_TEST = process.env.NODE_ENV === 'test';
const isNode = !IS_TEST && process && process.title && process.title.includes('node');
function throwMissingContextError() {
    throw new Error('The Overmind hook could not find an Overmind instance on the context of React. Please make sure you use the Provider component at the top of your application and expose the Overmind instance there. Please read more in the React guide on the website');
}
const context = react.createContext({});
let nextComponentId = 0;
exports.Provider = context.Provider;
function useForceRerender() {
    const [{ flushId }, setTick] = react.useState({ tick: 0, flushId: 0 });
    const forceRerender = react.useCallback((flushId) => {
        setTick(current => (Object.assign(Object.assign({}, current), { tick: current.tick + 1, flushId: flushId || current.flushId })));
    }, []);
    return {
        flushId,
        forceRerender
    };
}
let currentComponentInstanceId = 0;
const { ReactCurrentOwner, } = react.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
const useCurrentComponent = () => {
    return ReactCurrentOwner &&
        ReactCurrentOwner.current &&
        ReactCurrentOwner.current.elementType
        ? ReactCurrentOwner.current.elementType
        : {};
};
const useState = () => {
    const overmind = react.useContext(context);
    if (!overmind.mode) {
        throwMissingContextError();
    }
    if (isNode || overmind.mode.mode === overmind_1.MODE_SSR) {
        return overmind.state;
    }
    const trackingRef = react.useRef(null);
    const { flushId, forceRerender } = useForceRerender();
    if (!trackingRef.current) {
        trackingRef.current = {
            tree: overmind.proxyStateTree.getTrackStateTree(),
            hasUpdatedBeforeCommit: false,
            stopTrackingTask: scheduler_1.unstable_scheduleCallback(scheduler_1.unstable_getCurrentPriorityLevel(), () => {
                trackingRef.current.tree.stopTracking();
            })
        };
    }
    if (IS_PRODUCTION) {
        react.useLayoutEffect(() => {
            trackingRef.current.mounted = true;
            if (trackingRef.current.hasUpdatedBeforeCommit) {
                forceRerender();
            }
            return () => {
                ;
                overmind.proxyStateTree.disposeTree(trackingRef.current.tree);
            };
        }, []);
        react.useLayoutEffect(() => {
            if (trackingRef.current.stopTrackingTask) {
                scheduler_1.unstable_cancelCallback(trackingRef.current.stopTrackingTask);
                trackingRef.current.stopTrackingTask = null;
            }
            trackingRef.current.tree.stopTracking();
        });
        trackingRef.current.tree.track(() => {
            if (trackingRef.current.mounted) {
                forceRerender();
            }
            else {
                trackingRef.current.hasUpdatedBeforeCommit = true;
            }
        });
    }
    else {
        const component = useCurrentComponent();
        const name = component.name;
        component.__componentId =
            typeof component.__componentId === 'undefined'
                ? nextComponentId++
                : component.__componentId;
        const { current: componentInstanceId } = react.useRef(currentComponentInstanceId++);
        react.useLayoutEffect(() => {
            trackingRef.current.mounted = true;
            overmind.eventHub.emitAsync(overmind_1.EventType.COMPONENT_ADD, {
                componentId: component.__componentId,
                componentInstanceId,
                name,
                paths: Array.from(trackingRef.current.tree.pathDependencies),
            });
            if (trackingRef.current.hasUpdatedBeforeCommit) {
                forceRerender();
            }
            return () => {
                ;
                overmind.proxyStateTree.disposeTree(trackingRef.current.tree);
                overmind.eventHub.emitAsync(overmind_1.EventType.COMPONENT_REMOVE, {
                    componentId: component.__componentId,
                    componentInstanceId,
                    name,
                });
            };
        }, []);
        react.useLayoutEffect(() => {
            if (trackingRef.current.stopTrackingTask) {
                scheduler_1.unstable_cancelCallback(trackingRef.current.stopTrackingTask);
                trackingRef.current.stopTrackingTask = null;
            }
            trackingRef.current.tree.stopTracking();
            overmind.eventHub.emitAsync(overmind_1.EventType.COMPONENT_UPDATE, {
                componentId: component.__componentId,
                componentInstanceId,
                name,
                flushId,
                paths: Array.from(trackingRef.current.tree.pathDependencies),
            });
        });
        trackingRef.current.tree.track(() => {
            if (trackingRef.current.mounted) {
                forceRerender();
            }
            else {
                trackingRef.current.hasUpdatedBeforeCommit = true;
            }
        });
    }
    return trackingRef.current.tree.state;
};
const useActions = () => {
    const overmind = react.useContext(context);
    if (!overmind.mode) {
        throwMissingContextError();
    }
    return overmind.actions;
};
const useEffects = () => {
    const overmind = react.useContext(context);
    if (!overmind.mode) {
        throwMissingContextError();
    }
    return overmind.effects;
};
const useReaction = () => {
    const overmind = react.useContext(context);
    if (!overmind.mode) {
        throwMissingContextError();
    }
    return overmind.reaction;
};
exports.createStateHook = () => {
    return useState;
};
exports.createActionsHook = () => {
    return useActions;
};
exports.createEffectsHook = () => {
    return useEffects;
};
exports.createReactionHook = () => {
    return useReaction;
};
exports.createHook = () => {
    return () => {
        const state = useState();
        const actions = useActions();
        const effects = useEffects();
        const overmind = react.useContext(context);
        return {
            state,
            actions,
            effects,
            reaction: overmind.reaction,
            addMutationListener: overmind.addMutationListener
        };
    };
};
exports.createConnect = () => {
    return (component) => {
        let componentInstanceId = 0;
        const name = component.name;
        const populatedComponent = component;
        populatedComponent.__componentId =
            typeof populatedComponent.__componentId === 'undefined'
                ? nextComponentId++
                : populatedComponent.__componentId;
        const isClassComponent = component.prototype && typeof component.prototype.render === 'function';
        if (isClassComponent) {
            const originalRender = component.prototype.render;
            component.prototype.render = function () {
                if (this.props.overmind) {
                    return this.props.overmind.tree.trackScope(() => originalRender.call(this), this.props.overmind.onUpdate);
                }
                return originalRender.call(this);
            };
        }
        if (IS_PRODUCTION) {
            class HOC extends react.Component {
                constructor(props, context) {
                    super(props);
                    this.onUpdate = () => {
                        this.setState({
                            overmind: {
                                state: this.tree.state,
                                effects: this.overmind.effects,
                                actions: this.overmind.actions,
                                addMutationListener: this.overmind.addMutationListener,
                                onUpdate: this.onUpdate,
                                tree: this.tree,
                                reaction: this.overmind.reaction,
                            },
                        });
                    };
                    if (!context) {
                        throwMissingContextError();
                    }
                    this.overmind = context;
                    this.tree = this.overmind.proxyStateTree.getTrackStateTree();
                    this.state = {
                        overmind: {
                            state: this.tree.state,
                            effects: this.overmind.effects,
                            actions: this.overmind.actions,
                            addMutationListener: this.overmind.addMutationListener,
                            onUpdate: this.onUpdate,
                            tree: this.tree,
                            reaction: this.overmind.reaction,
                        },
                    };
                    this.wrappedComponent = (...args) => this.tree.trackScope(() => component(...args), this.onUpdate);
                }
                componentWillUnmount() {
                    this.overmind.proxyStateTree.disposeTree(this.tree);
                }
                render() {
                    if (isClassComponent) {
                        return react.createElement(component, Object.assign(Object.assign({}, this.props), { overmind: this.state.overmind }));
                    }
                    return react.createElement(this.wrappedComponent, Object.assign(Object.assign({}, this.props), { overmind: this.state.overmind }));
                }
            }
            HOC.contextType = context;
            return HOC;
        }
        else {
            class HOC extends react.Component {
                constructor(props, context) {
                    super(props);
                    this.componentInstanceId = componentInstanceId++;
                    this.currentFlushId = 0;
                    this.onUpdate = (mutatons, paths, flushId) => {
                        this.currentFlushId = flushId;
                        this.isUpdating = true;
                        this.setState({
                            overmind: {
                                state: this.tree.state,
                                effects: this.overmind.effects,
                                actions: this.overmind.actions,
                                addMutationListener: this.overmind.addMutationListener,
                                onUpdate: this.onUpdate,
                                tree: this.tree,
                                reaction: this.overmind.reaction,
                            },
                        });
                    };
                    if (!context) {
                        throwMissingContextError();
                    }
                    this.overmind = context;
                    this.tree = this.overmind.proxyStateTree.getTrackStateTree();
                    this.state = {
                        overmind: {
                            state: this.tree.state,
                            effects: this.overmind.effects,
                            actions: this.overmind.actions,
                            addMutationListener: this.overmind.addMutationListener,
                            onUpdate: this.onUpdate,
                            tree: this.tree,
                            reaction: this.overmind.reaction,
                        },
                    };
                    this.wrappedComponent = (...args) => this.tree.trackScope(() => component(...args), this.onUpdate);
                }
                componentDidMount() {
                    this.overmind.eventHub.emitAsync(overmind_1.EventType.COMPONENT_ADD, {
                        componentId: populatedComponent.__componentId,
                        componentInstanceId: this.componentInstanceId,
                        name,
                        paths: Array.from(this.tree.pathDependencies),
                    });
                }
                componentDidUpdate() {
                    if (this.isUpdating) {
                        this.overmind.eventHub.emitAsync(overmind_1.EventType.COMPONENT_UPDATE, {
                            componentId: populatedComponent.__componentId,
                            componentInstanceId: this.componentInstanceId,
                            name,
                            flushId: this.currentFlushId,
                            paths: Array.from(this.tree.pathDependencies),
                        });
                        this.isUpdating = false;
                    }
                }
                componentWillUnmount() {
                    this.overmind.proxyStateTree.disposeTree(this.tree);
                    this.overmind.eventHub.emitAsync(overmind_1.EventType.COMPONENT_REMOVE, {
                        componentId: populatedComponent.__componentId,
                        componentInstanceId: this.componentInstanceId,
                        name,
                    });
                }
                render() {
                    if (isClassComponent) {
                        return react.createElement(component, Object.assign(Object.assign({}, this.props), { overmind: this.state.overmind }));
                    }
                    return react.createElement(this.wrappedComponent, Object.assign(Object.assign({}, this.props), { overmind: this.state.overmind }));
                }
            }
            HOC.contextType = context;
            Object.defineProperties(HOC, {
                name: {
                    value: 'Connect' + (component.displayName || component.name || ''),
                },
            });
            return HOC;
        }
    };
};
//# sourceMappingURL=index.js.map