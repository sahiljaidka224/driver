"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const overmind_1 = require("overmind");
const React = require("react");
const renderer = require("react-test-renderer");
const _1 = require("./");
describe('React', () => {
    test('should connect state and actions to stateless components', () => {
        expect.assertions(2);
        let didCallAction = false;
        const doThis = () => {
            didCallAction = true;
        };
        const config = {
            state: {
                foo: 'bar',
            },
            actions: {
                doThis,
            },
        };
        const app = new overmind_1.Overmind(config);
        const connect = _1.createConnect();
        const Component = ({ overmind }) => {
            overmind.actions.doThis();
            return React.createElement("h1", null, overmind.state.foo);
        };
        const ConnectedComponent = connect(Component);
        const tree = renderer
            .create(React.createElement(_1.Provider, { value: app },
            React.createElement(ConnectedComponent, null)))
            .toJSON();
        expect(didCallAction).toBe(true);
        expect(tree).toMatchSnapshot();
    });
    test('should connect actions and state to class components', () => {
        expect.assertions(2);
        let didCallAction = false;
        const doThis = () => {
            didCallAction = true;
        };
        const config = {
            state: {
                foo: 'bar',
            },
            actions: {
                doThis,
            },
        };
        const app = new overmind_1.Overmind(config);
        const connect = _1.createConnect();
        class Component extends React.Component {
            componentDidMount() {
                this.props.overmind.actions.doThis();
            }
            render() {
                const { overmind } = this.props;
                return React.createElement("h1", null, overmind.state.foo);
            }
        }
        const ConnectedComponent = connect(Component);
        const tree = renderer
            .create(React.createElement(_1.Provider, { value: app },
            React.createElement(ConnectedComponent, null)))
            .toJSON();
        expect(didCallAction).toBe(true);
        expect(tree).toMatchSnapshot();
    });
    test('should allow using component as normal, even when not connected', () => {
        expect.assertions(2);
        const config = {
            state: {
                foo: 'bar',
            },
        };
        const app = new overmind_1.Overmind(config);
        const connect = _1.createConnect();
        class Component extends React.Component {
            render() {
                const { overmind } = this.props;
                return React.createElement("h1", null, overmind ? overmind.state.foo : 'nada');
            }
        }
        const ConnectedComponent = connect(Component);
        const tree = renderer
            .create(React.createElement(_1.Provider, { value: app },
            React.createElement(ConnectedComponent, null)))
            .toJSON();
        const tree2 = renderer.create(React.createElement(Component, { overmind: null })).toJSON();
        expect(tree).toMatchSnapshot();
        expect(tree2).toMatchSnapshot();
    });
    test('should preserve component name', () => {
        const app = new overmind_1.Overmind({});
        const connect = _1.createConnect();
        class FooComponent extends React.Component {
            render() {
                return React.createElement("h1", null, "hop");
            }
        }
        function BarComponent() {
            return React.createElement("div", null);
        }
        const ConnectedFoo = connect(FooComponent);
        const ConnectedBar = connect(BarComponent);
        expect(ConnectedFoo.name).toBe('ConnectFooComponent');
        expect(ConnectedBar.name).toBe('ConnectBarComponent');
    });
    test('should allow using shouldComponentUpdate', () => {
        let renderCount = 0;
        const doThis = ({ state }) => {
            state.foo = 'bar2';
        };
        const config = {
            state: {
                foo: 'bar',
            },
            actions: {
                doThis,
            },
        };
        const app = new overmind_1.Overmind(config);
        const connect = _1.createConnect();
        class FooComponent extends React.Component {
            shouldComponentUpdate(nextProps) {
                return this.props.overmind !== nextProps.overmind;
            }
            render() {
                renderCount++;
                return React.createElement("h1", null, this.props.overmind.state.foo);
            }
        }
        const ConnectedFoo = connect(FooComponent);
        const tree = renderer
            .create(React.createElement(_1.Provider, { value: app },
            React.createElement(ConnectedFoo, null)))
            .toJSON();
        expect(renderCount).toBe(1);
        app.actions.doThis();
        expect(renderCount).toBe(2);
    });
    test('should allow using hooks', () => {
        let renderCount = 0;
        const doThis = ({ state }) => {
            state.foo = 'bar2';
        };
        const config = {
            state: {
                foo: 'bar',
            },
            actions: {
                doThis,
            },
        };
        const app = new overmind_1.Overmind(config);
        const useOvermind = _1.createHook();
        const FooComponent = () => {
            const { state } = useOvermind();
            renderCount++;
            return React.createElement("h1", null, state.foo);
        };
        const tree = renderer
            .create(React.createElement(_1.Provider, { value: app },
            React.createElement(FooComponent, null)))
            .toJSON();
        expect(renderCount).toBe(1);
        renderer.act(() => {
            app.actions.doThis();
        });
        expect(renderCount).toBe(2);
        expect(tree).toMatchSnapshot();
    });
    test('should allow using mocked Overmind', () => {
        let renderCount = 0;
        const doThis = ({ state }) => {
            state.foo = 'bar2';
        };
        const config = {
            state: {
                foo: 'bar',
            },
            actions: {
                doThis,
            },
        };
        const useOvermind = _1.createHook();
        const FooComponent = () => {
            const { state } = useOvermind();
            renderCount++;
            return React.createElement("h1", null, state.foo);
        };
        const mock = overmind_1.createOvermindMock(config);
        const tree = renderer
            .create(React.createElement(_1.Provider, { value: mock },
            React.createElement(FooComponent, null)))
            .toJSON();
        expect(renderCount).toBe(1);
        expect(tree).toMatchSnapshot();
    });
    test('should be able to use Provider with connect', () => {
        let renderCount = 0;
        const doThis = ({ state }) => {
            state.foo = 'bar2';
        };
        const config = {
            state: {
                foo: 'bar',
            },
            actions: {
                doThis,
            },
        };
        const connect = _1.createConnect();
        const FooComponent = ({ overmind }) => {
            renderCount++;
            return React.createElement("h1", null, overmind.state.foo);
        };
        const ConnectedFooComponent = connect(FooComponent);
        const mock = overmind_1.createOvermindMock(config);
        const tree = renderer
            .create(React.createElement(_1.Provider, { value: mock },
            React.createElement(ConnectedFooComponent, null)))
            .toJSON();
        expect(renderCount).toBe(1);
        expect(tree).toMatchSnapshot();
    });
    test('should throw an error without provider', () => {
        expect.assertions(1);
        const config = {
            state: {
                foo: 'bar',
            },
        };
        const useApp = _1.createHook();
        const FooComponent = () => {
            const { state } = useApp();
            return React.createElement("h1", null, state.foo);
        };
        expect(() => {
            renderer
                .create(React.createElement(FooComponent, null))
                .toJSON();
        }).toThrow(Error);
    });
});
//# sourceMappingURL=index.test.js.map