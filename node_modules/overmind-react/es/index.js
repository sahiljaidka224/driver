import 'proxy-state-tree';
import { unstable_scheduleCallback, unstable_getCurrentPriorityLevel, unstable_cancelCallback } from 'scheduler';
import { EventType, MODE_SSR, } from 'overmind';
import * as react from 'react';
const IS_PRODUCTION = process.env.NODE_ENV === 'production';
const IS_TEST = process.env.NODE_ENV === 'test';
const isNode = !IS_TEST && process && process.title && process.title.includes('node');
function throwMissingContextError() {
    throw new Error('The Overmind hook could not find an Overmind instance on the context of React. Please make sure you use the Provider component at the top of your application and expose the Overmind instance there. Please read more in the React guide on the website');
}
const context = react.createContext({});
let nextComponentId = 0;
export const Provider = context.Provider;
function useForceRerender() {
    const [{ flushId }, setTick] = react.useState({ tick: 0, flushId: 0 });
    const forceRerender = react.useCallback((flushId) => {
        setTick(current => (Object.assign(Object.assign({}, current), { tick: current.tick + 1, flushId: flushId || current.flushId })));
    }, []);
    return {
        flushId,
        forceRerender
    };
}
let currentComponentInstanceId = 0;
const { ReactCurrentOwner, } = react.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
const useCurrentComponent = () => {
    return ReactCurrentOwner &&
        ReactCurrentOwner.current &&
        ReactCurrentOwner.current.elementType
        ? ReactCurrentOwner.current.elementType
        : {};
};
const useState = () => {
    const overmind = react.useContext(context);
    if (!overmind.mode) {
        throwMissingContextError();
    }
    if (isNode || overmind.mode.mode === MODE_SSR) {
        return overmind.state;
    }
    const trackingRef = react.useRef(null);
    const { flushId, forceRerender } = useForceRerender();
    if (!trackingRef.current) {
        trackingRef.current = {
            tree: overmind.proxyStateTree.getTrackStateTree(),
            hasUpdatedBeforeCommit: false,
            stopTrackingTask: unstable_scheduleCallback(unstable_getCurrentPriorityLevel(), () => {
                trackingRef.current.tree.stopTracking();
            })
        };
    }
    if (IS_PRODUCTION) {
        react.useLayoutEffect(() => {
            trackingRef.current.mounted = true;
            if (trackingRef.current.hasUpdatedBeforeCommit) {
                forceRerender();
            }
            return () => {
                ;
                overmind.proxyStateTree.disposeTree(trackingRef.current.tree);
            };
        }, []);
        react.useLayoutEffect(() => {
            if (trackingRef.current.stopTrackingTask) {
                unstable_cancelCallback(trackingRef.current.stopTrackingTask);
                trackingRef.current.stopTrackingTask = null;
            }
            trackingRef.current.tree.stopTracking();
        });
        trackingRef.current.tree.track(() => {
            if (trackingRef.current.mounted) {
                forceRerender();
            }
            else {
                trackingRef.current.hasUpdatedBeforeCommit = true;
            }
        });
    }
    else {
        const component = useCurrentComponent();
        const name = component.name;
        component.__componentId =
            typeof component.__componentId === 'undefined'
                ? nextComponentId++
                : component.__componentId;
        const { current: componentInstanceId } = react.useRef(currentComponentInstanceId++);
        react.useLayoutEffect(() => {
            trackingRef.current.mounted = true;
            overmind.eventHub.emitAsync(EventType.COMPONENT_ADD, {
                componentId: component.__componentId,
                componentInstanceId,
                name,
                paths: Array.from(trackingRef.current.tree.pathDependencies),
            });
            if (trackingRef.current.hasUpdatedBeforeCommit) {
                forceRerender();
            }
            return () => {
                ;
                overmind.proxyStateTree.disposeTree(trackingRef.current.tree);
                overmind.eventHub.emitAsync(EventType.COMPONENT_REMOVE, {
                    componentId: component.__componentId,
                    componentInstanceId,
                    name,
                });
            };
        }, []);
        react.useLayoutEffect(() => {
            if (trackingRef.current.stopTrackingTask) {
                unstable_cancelCallback(trackingRef.current.stopTrackingTask);
                trackingRef.current.stopTrackingTask = null;
            }
            trackingRef.current.tree.stopTracking();
            overmind.eventHub.emitAsync(EventType.COMPONENT_UPDATE, {
                componentId: component.__componentId,
                componentInstanceId,
                name,
                flushId,
                paths: Array.from(trackingRef.current.tree.pathDependencies),
            });
        });
        trackingRef.current.tree.track(() => {
            if (trackingRef.current.mounted) {
                forceRerender();
            }
            else {
                trackingRef.current.hasUpdatedBeforeCommit = true;
            }
        });
    }
    return trackingRef.current.tree.state;
};
const useActions = () => {
    const overmind = react.useContext(context);
    if (!overmind.mode) {
        throwMissingContextError();
    }
    return overmind.actions;
};
const useEffects = () => {
    const overmind = react.useContext(context);
    if (!overmind.mode) {
        throwMissingContextError();
    }
    return overmind.effects;
};
const useReaction = () => {
    const overmind = react.useContext(context);
    if (!overmind.mode) {
        throwMissingContextError();
    }
    return overmind.reaction;
};
export const createStateHook = () => {
    return useState;
};
export const createActionsHook = () => {
    return useActions;
};
export const createEffectsHook = () => {
    return useEffects;
};
export const createReactionHook = () => {
    return useReaction;
};
export const createHook = () => {
    return () => {
        const state = useState();
        const actions = useActions();
        const effects = useEffects();
        const overmind = react.useContext(context);
        return {
            state,
            actions,
            effects,
            reaction: overmind.reaction,
            addMutationListener: overmind.addMutationListener
        };
    };
};
export const createConnect = () => {
    return (component) => {
        let componentInstanceId = 0;
        const name = component.name;
        const populatedComponent = component;
        populatedComponent.__componentId =
            typeof populatedComponent.__componentId === 'undefined'
                ? nextComponentId++
                : populatedComponent.__componentId;
        const isClassComponent = component.prototype && typeof component.prototype.render === 'function';
        if (isClassComponent) {
            const originalRender = component.prototype.render;
            component.prototype.render = function () {
                if (this.props.overmind) {
                    return this.props.overmind.tree.trackScope(() => originalRender.call(this), this.props.overmind.onUpdate);
                }
                return originalRender.call(this);
            };
        }
        if (IS_PRODUCTION) {
            class HOC extends react.Component {
                constructor(props, context) {
                    super(props);
                    this.onUpdate = () => {
                        this.setState({
                            overmind: {
                                state: this.tree.state,
                                effects: this.overmind.effects,
                                actions: this.overmind.actions,
                                addMutationListener: this.overmind.addMutationListener,
                                onUpdate: this.onUpdate,
                                tree: this.tree,
                                reaction: this.overmind.reaction,
                            },
                        });
                    };
                    if (!context) {
                        throwMissingContextError();
                    }
                    this.overmind = context;
                    this.tree = this.overmind.proxyStateTree.getTrackStateTree();
                    this.state = {
                        overmind: {
                            state: this.tree.state,
                            effects: this.overmind.effects,
                            actions: this.overmind.actions,
                            addMutationListener: this.overmind.addMutationListener,
                            onUpdate: this.onUpdate,
                            tree: this.tree,
                            reaction: this.overmind.reaction,
                        },
                    };
                    this.wrappedComponent = (...args) => this.tree.trackScope(() => component(...args), this.onUpdate);
                }
                componentWillUnmount() {
                    this.overmind.proxyStateTree.disposeTree(this.tree);
                }
                render() {
                    if (isClassComponent) {
                        return react.createElement(component, Object.assign(Object.assign({}, this.props), { overmind: this.state.overmind }));
                    }
                    return react.createElement(this.wrappedComponent, Object.assign(Object.assign({}, this.props), { overmind: this.state.overmind }));
                }
            }
            HOC.contextType = context;
            return HOC;
        }
        else {
            class HOC extends react.Component {
                constructor(props, context) {
                    super(props);
                    this.componentInstanceId = componentInstanceId++;
                    this.currentFlushId = 0;
                    this.onUpdate = (mutatons, paths, flushId) => {
                        this.currentFlushId = flushId;
                        this.isUpdating = true;
                        this.setState({
                            overmind: {
                                state: this.tree.state,
                                effects: this.overmind.effects,
                                actions: this.overmind.actions,
                                addMutationListener: this.overmind.addMutationListener,
                                onUpdate: this.onUpdate,
                                tree: this.tree,
                                reaction: this.overmind.reaction,
                            },
                        });
                    };
                    if (!context) {
                        throwMissingContextError();
                    }
                    this.overmind = context;
                    this.tree = this.overmind.proxyStateTree.getTrackStateTree();
                    this.state = {
                        overmind: {
                            state: this.tree.state,
                            effects: this.overmind.effects,
                            actions: this.overmind.actions,
                            addMutationListener: this.overmind.addMutationListener,
                            onUpdate: this.onUpdate,
                            tree: this.tree,
                            reaction: this.overmind.reaction,
                        },
                    };
                    this.wrappedComponent = (...args) => this.tree.trackScope(() => component(...args), this.onUpdate);
                }
                componentDidMount() {
                    this.overmind.eventHub.emitAsync(EventType.COMPONENT_ADD, {
                        componentId: populatedComponent.__componentId,
                        componentInstanceId: this.componentInstanceId,
                        name,
                        paths: Array.from(this.tree.pathDependencies),
                    });
                }
                componentDidUpdate() {
                    if (this.isUpdating) {
                        this.overmind.eventHub.emitAsync(EventType.COMPONENT_UPDATE, {
                            componentId: populatedComponent.__componentId,
                            componentInstanceId: this.componentInstanceId,
                            name,
                            flushId: this.currentFlushId,
                            paths: Array.from(this.tree.pathDependencies),
                        });
                        this.isUpdating = false;
                    }
                }
                componentWillUnmount() {
                    this.overmind.proxyStateTree.disposeTree(this.tree);
                    this.overmind.eventHub.emitAsync(EventType.COMPONENT_REMOVE, {
                        componentId: populatedComponent.__componentId,
                        componentInstanceId: this.componentInstanceId,
                        name,
                    });
                }
                render() {
                    if (isClassComponent) {
                        return react.createElement(component, Object.assign(Object.assign({}, this.props), { overmind: this.state.overmind }));
                    }
                    return react.createElement(this.wrappedComponent, Object.assign(Object.assign({}, this.props), { overmind: this.state.overmind }));
                }
            }
            HOC.contextType = context;
            Object.defineProperties(HOC, {
                name: {
                    value: 'Connect' + (component.displayName || component.name || ''),
                },
            });
            return HOC;
        }
    };
};
//# sourceMappingURL=index.js.map